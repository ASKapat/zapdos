
[Adaptivity]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  cycles_per_step                = 1                           # The number of adaptive steps to use when on each timestep during a Transient ...
                                                               # simulation.
  initial_marker                 =                             # The name of the Marker to use to adapt the mesh during initial refinement.
  initial_steps                  = 0                           # The number of adaptive steps to do based on the initial condition.
  marker                         =                             # The name of the Marker to use to actually adapt the mesh.
  max_h_level                    = 0                           # Maximum number of times a single element can be refined. If 0 then infinite.
  start_time                     = -1.79769e+308               # The time that adaptivity will be active after.
  steps                          = 0                           # The number of adaptive steps to use when doing a Steady simulation.
  stop_time                      = 1.79769e+308                # The time after which adaptivity will no longer be active.

  [./Indicators]

    [./*]
      active                     = __all__                     # If specified only the blocks named will be visited and made active
      block                      =                             # The block id where this object lives.
    [../]

    [./AnalyticalDiffIndicator]
      block                      = ANY_BLOCK_ID                # block ID or name where the object works
      function                   = (required)                  # The analytic solution to compare against
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      type                       = AnalyticalDiffIndicator
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
      variable                   = (required)                  # The name of the variable that this Indicator operates on
    [../]

    [./AnalyticalIndicator]
      block                      = ANY_BLOCK_ID                # block ID or name where the object works
      function                   = (required)                  # The analytic solution to compare against
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      type                       = AnalyticalIndicator
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
      variable                   = (required)                  # The name of the variable that this Indicator operates on
    [../]

    [./GradientJumpIndicator]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      scale_by_flux_faces        = 0                           # Whether or not to scale the error values by the number of flux faces. ...
                                                               # This attempts to not penalize elements on boundaries for having less ...
                                                               # neighbors.
      type                       = GradientJumpIndicator
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
      variable                   = (required)                  # The name of the variable that this side indicator applies to
    [../]

    [./LaplacianJumpIndicator]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      scale_by_flux_faces        = 0                           # Whether or not to scale the error values by the number of flux faces. ...
                                                               # This attempts to not penalize elements on boundaries for having less ...
                                                               # neighbors.
      type                       = LaplacianJumpIndicator
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
      variable                   = (required)                  # The name of the variable that this side indicator applies to
    [../]
  [../]

  [./Markers]

    [./*]
      active                     = __all__                     # If specified only the blocks named will be visited and made active
      block                      =                             # The block id where this object lives.
    [../]

    [./BoxMarker]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      bottom_left                = (required)                  # The bottom left point (in x,y,z with spaces in-between).
      inside                     = (required)                  # How to mark elements inside the box.
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      outside                    = (required)                  # How to mark elements outside the box.
      top_right                  = (required)                  # The bottom left point (in x,y,z with spaces in-between).
      type                       = BoxMarker
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    [../]

    [./ComboMarker]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      markers                    = (required)                  # The Markers to combine.
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      type                       = ComboMarker
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    [../]

    [./ErrorFractionMarker]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      coarsen                    = 0                           # Elements within this percentage of the min error will be coarsened.  ...
                                                               # Must be between 0 and 1!
      indicator                  = (required)                  # The name of the Indicator that this Marker uses.
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      refine                     = 0                           # Elements within this percentage of the max error will be refined.  Must ...
                                                               # be between 0 and 1!
      type                       = ErrorFractionMarker
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    [../]

    [./ErrorToleranceMarker]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      coarsen                    = 0                           # Elements with error less than this will be coarsened.
      indicator                  = (required)                  # The name of the Indicator that this Marker uses.
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      refine                     = 1.79769e+308                # Elements with error more than this will be refined.
      type                       = ErrorToleranceMarker
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    [../]

    [./OrientedBoxMarker]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      center                     = (required)                  # The center (many people spell this 'center') of the box.
      height                     = (required)                  # The height of the box
      inside                     = (required)                  # How to mark elements inside the box.
      length                     = (required)                  # The length of the box
      length_direction           = (required)                  # The direction along which the length is oriented (must be perpendicular ...
                                                               # to width_direction).
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      outside                    = (required)                  # How to mark elements outside the box.
      type                       = OrientedBoxMarker
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
      width                      = (required)                  # The width of the box
      width_direction            = (required)                  # The direction along which the width is oriented.
    [../]

    [./UniformMarker]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      mark                       = (required)                  # How to mark elements.
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      type                       = UniformMarker
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    [../]

    [./ValueRangeMarker]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      buffer_size                = 0                           # A buffer zone value added to both ends of the range where a third_state ...
                                                               # marker can be returned.
      invert                     = 0                           # If this is true then values inside the range will be coarsened, and values ...
                                                               # outside the range will be refined.
      lower_bound                = (required)                  # The lower bound value for the range.
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      third_state                = DONT_MARK                   # The Marker state to apply to values in the buffer zone (both ends of ...
                                                               # the range).
      type                       = ValueRangeMarker
      upper_bound                = (required)                  # The upper bound value for the range.
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
      variable                   = (required)                  # The variable whose values are used in this marker.
    [../]

    [./ValueThresholdMarker]
      block                      =                             # The list of block ids (SubdomainID) that this object will be applied
      coarsen                    =                             # The threshold value for coarsening.  Elements with variable values beyond ...
                                                               # this will be marked for coarsening.
      invert                     = 0                           # If this is true then values _below_ 'refine' will be refined and _above_ ...
                                                               # 'coarsen' will be coarsened.
      outputs                    =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
      refine                     =                             # The threshold value for refinement.  Elements with variable values beyond ...
                                                               # this will be marked for refinement.
      third_state                = DONT_MARK                   # The Marker state to apply to values falling in-between the coarsen and ...
                                                               # refine thresholds.
      type                       = ValueThresholdMarker
      use_displaced_mesh         = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
      variable                   = (required)                  # The values of this variable will be compared to 'refine' and 'coarsen' ...
                                                               # to see what should be done with the element
    [../]
  [../]
[]

[AuxKernels]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./AdvectiveFlux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    electron_density             = (required)                  # The electron density.
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    mobility                     = (required)                  # What mobility to use
    potential                    = (required)                  # The gradient of the potential will be used to compute the advection velocity.
    seed                         = 0                           # The seed for the master random number generator
    type                         = AdvectiveFlux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./AlphaTimesHSize]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    potential                    = (required)                  # The potential
    seed                         = 0                           # The seed for the master random number generator
    type                         = AlphaTimesHSize
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./BoundsAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    bounded_variable             = (required)                  # The variable to be bounded
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    lower                        =                             # The lower bound for the variable
    seed                         = 0                           # The seed for the master random number generator
    type                         = BoundsAux
    upper                        =                             # The upper bound for the variable
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./ChargeDensity]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    electron_density             = (required)                  # The electron density
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    ion_density                  = (required)                  # The ion density
    seed                         = 0                           # The seed for the master random number generator
    type                         = ChargeDensity
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./ConstantAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = ConstantAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = 0                           # Some constant value that can be read from the input file
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./DebugResidualAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    debug_variable               = (required)                  # The variable that is being debugged.
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = DebugResidualAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./DiffusiveFlux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diffusivity                  = (required)                  # What diffusivity to use
    electron_density             = (required)                  # The electron density.
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = DiffusiveFlux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./EFieldMag]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    potential                    = (required)                  # The potential
    seed                         = 0                           # The seed for the master random number generator
    type                         = EFieldMag
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./Ex]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    potential                    = (required)                  # The potential
    seed                         = 0                           # The seed for the master random number generator
    type                         = Ex
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./FunctionAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The function to use as the value
    seed                         = 0                           # The seed for the master random number generator
    type                         = FunctionAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./GapValueAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    normal_smoothing_distance    =                             # Distance from edge in parametric coordinates over which to smooth contact ...
                                                               # normal
    normal_smoothing_method      =                             # Method to use to smooth normals (edge_based|nodal_normal_based)
    order                        = FIRST                       # The finite element order
    paired_boundary              = (required)                  # The boundary on the other side of a gap.
    paired_variable              = (required)                  # The variable to get the value of.
    seed                         = 0                           # The seed for the master random number generator
    tangential_tolerance         =                             # Tangential distance to extend edges of contact surfaces
    type                         = GapValueAux
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
    warnings                     = 0                           # Whether to output warning messages concerning nodes not being found
  [../]

  [./HSize]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = HSize
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./IonSrcTerm]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    electron_density             = (required)                  # The electron density
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    potential                    = (required)                  # The potential
    seed                         = 0                           # The seed for the master random number generator
    type                         = IonSrcTerm
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialRealAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialRealAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialRealDenseMatrixAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    column                       = 0                           # The column component to consider for this kernel
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    row                          = 0                           # The row component to consider for this kernel
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialRealDenseMatrixAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialRealTensorValueAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    column                       = 0                           # The column component to consider for this kernel
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    row                          = 0                           # The row component to consider for this kernel
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialRealTensorValueAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialRealVectorValueAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    component                    = 0                           # The vector component to consider for this kernel
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialRealVectorValueAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialStdVectorAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    index                        = 0                           # The index to consider for this kernel
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialStdVectorAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./NearestNodeDistanceAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    paired_boundary              = (required)                  # The boundary to find the distance to.
    seed                         = 0                           # The seed for the master random number generator
    type                         = NearestNodeDistanceAux
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./NearestNodeValueAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    paired_boundary              = (required)                  # The boundary to get the value from.
    paired_variable              = (required)                  # The variable to get the value of.
    seed                         = 0                           # The seed for the master random number generator
    type                         = NearestNodeValueAux
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./NormalizationAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    normal_factor                = 1                           # The normalization factor
    normalization                = (required)                  # The postprocessor on the source
    seed                         = 0                           # The seed for the master random number generator
    source_variable              = (required)                  # The variable to be normalized
    type                         = NormalizationAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./ParsedAux]
    args                         =                             # coupled variables
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    constant_expressions         =                             # Vector of values for the constants in constant_names (can be an FParser ...
                                                               # expression)
    constant_names               =                             # Vector of constants used in the parsed function (use this for kB etc.)
    disable_fpoptimizer          = 0                           # Disable the function parser algebraic optimizer
    enable_jit                   = 1                           # enable just-in-time compilation of function expressions for faster evaluation
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    fail_on_evalerror            = 0                           # Fail fatally if a function evaluation returns an error code (otherwise ...
                                                               # just pass on NaN)
    function                     = (required)                  # function expression
    seed                         = 0                           # The seed for the master random number generator
    type                         = ParsedAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./PenetrationAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    normal_smoothing_distance    =                             # Distance from edge in parametric coordinates over which to smooth contact ...
                                                               # normal
    normal_smoothing_method      =                             # Method to use to smooth normals (edge_based|nodal_normal_based)
    order                        = FIRST                       # The finite element order
    paired_boundary              = (required)                  # The boundary to be penetrated
    quantity                     = distance                    # The quantity to recover from the available penetration information
    seed                         = 0                           # The seed for the master random number generator
    tangential_tolerance         =                             # Tangential distance to extend edges of contact surfaces
    type                         = PenetrationAux
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./ProcessorIDAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = ProcessorIDAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./QuotientAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    denominator                  =                             # The downstairs of the quotient variable
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    numerator                    =                             # The upstairs of the quotient variable
    seed                         = 0                           # The seed for the master random number generator
    type                         = QuotientAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./SelfAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = SelfAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./Sigma]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    some_var                     = (required)                  # The advected variable needed for determining tau.
    type                         = Sigma
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./SolutionAux]
    add_factor                   = 0                           # Add this value (b) to the solution (x): ax+b, where a is the 'scale_factor'
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    direct                       = 0                           # If true the meshes must be the same and then the values are simply copied ...
                                                               # over.
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    from_variable                =                             # The name of the variable to extract from the file
    scale_factor                 = 1                           # Scale factor (a)  to be applied to the solution (x): ax+b, where b is ...
                                                               # the 'add_factor'
    seed                         = 0                           # The seed for the master random number generator
    solution                     = (required)                  # The name of the SolutionUserObject
    type                         = SolutionAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./SpatialUserObjectAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = SpatialUserObjectAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    user_object                  = (required)                  # The UserObject UserObject to get values from.  Note that the UserObject ...
                                                               # _must_ implement the spatialValue() virtual function!
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./VariableGradientComponent]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    component                    =                             # The gradient component to compute
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    gradient_variable            = (required)                  # The variable from which to compute the gradient component
    seed                         = 0                           # The seed for the master random number generator
    type                         = VariableGradientComponent
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./VectorMagnitudeAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = VectorMagnitudeAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
    x                            = (required)                  # x-component of the vector
    y                            =                             # y-component of the vector
    z                            =                             # z-component of the vector
  [../]

  [./Velocity]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    some_var                     = (required)                  # The advected variable needed for determining tau.
    type                         = Velocity
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./VelocityH]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    some_var                     = (required)                  # The advected variable needed for determining tau.
    type                         = VelocityH
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./VelocityMag]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = VelocityMag
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]
[]

[AuxScalarKernels]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./ConstantScalarAux]
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    type                         = ConstantScalarAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = (required)                  # The value to be set to the scalar variable.
    variable                     = (required)                  # The name of the variable that this kernel operates on
  [../]

  [./FunctionScalarAux]
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The function to set the scalar variable value.
    type                         = FunctionScalarAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this kernel operates on
  [../]

  [./QuotientScalarAux]
    denominator                  =                             # The downstairs of the quotient variable
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    numerator                    =                             # The upstairs of the quotient variable
    type                         = QuotientScalarAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this kernel operates on
  [../]
[]

[AuxVariables]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
    block                        =                             # The block id where this variable lives
    family                       = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
    initial_condition            = 0                           # Specifies the initial condition for this variable
    order                        = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    initial_from_file_timestep   = 2                           # Gives the timestep for which to read a solution from a file for a given ...
                                                               # variable
    initial_from_file_var        =                             # Gives the name of a variable for which to read an initial condition from ...
                                                               # a mesh file

    [./InitialCondition]
      active                     = __all__                     # If specified only the blocks named will be visited and made active

      [./<type>]

        [./BoundingBoxIC]
          block                  =                             # The list of block ids (SubdomainID) that this object will be applied
          boundary               =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
          inside                 = 0                           # The value of the variable inside the box
          outside                = 0                           # The value of the variable outside the box
          type                   = BoundingBoxIC
          variable               = (required)                  # The variable this initial condition is supposed to provide values for.
          x1                     = (required)                  # The x coordinate of the lower left-hand corner of the box
          x2                     = (required)                  # The x coordinate of the upper right-hand corner of the box
          y1                     = (required)                  # The y coordinate of the lower left-hand corner of the box
          y2                     = (required)                  # The y coordinate of the upper right-hand corner of the box
          z1                     = 0                           # The z coordinate of the lower left-hand corner of the box
          z2                     = 0                           # The z coordinate of the upper right-hand corner of the box
        [../]

        [./ConstantIC]
          block                  =                             # The list of block ids (SubdomainID) that this object will be applied
          boundary               =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
          type                   = ConstantIC
          value                  = (required)                  # The value to be set in IC
          variable               = (required)                  # The variable this initial condition is supposed to provide values for.
        [../]

        [./FunctionIC]
          block                  =                             # The list of block ids (SubdomainID) that this object will be applied
          boundary               =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
          function               = (required)                  # The initial condition function.
          type                   = FunctionIC
          variable               = (required)                  # The variable this initial condition is supposed to provide values for.
        [../]

        [./RandomIC]
          block                  =                             # The list of block ids (SubdomainID) that this object will be applied
          boundary               =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
          max                    = 1                           # Upper bound of the randomly generated values
          min                    = 0                           # Lower bound of the randomly generated values
          seed                   = 0                           # Seed value for the random number generator
          type                   = RandomIC
          variable               = (required)                  # The variable this initial condition is supposed to provide values for.
        [../]

        [./ScalarComponentIC]
          type                   = ScalarComponentIC
          values                 = (required)                  # Initial values to initialize the scalar variable.
          variable               =                             # The variable this initial condition is supposed to provide values for.
        [../]

        [./ScalarConstantIC]
          type                   = ScalarConstantIC
          value                  = 0
          variable               =                             # The variable this initial condition is supposed to provide values for.
        [../]
      [../]
    [../]
  [../]
[]

[BCs]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./AdvectionDoNothingBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = AdvectionDoNothingBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
    velocity_function            = (required)                  # the name of the velocity function to utilize
  [../]

  [./ConvectiveFluxBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    duration                     = 0
    final                        = 500
    initial                      = 500
    rate                         = 7500
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ConvectiveFluxBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./DGFunctionDiffusionDirichletBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    epsilon                      = (required)                  # Epsilon
    function                     = (required)                  # The forcing function.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    sigma                        = (required)                  # Sigma
    type                         = DGFunctionDiffusionDirichletBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = 0                           # The value the variable should have on the boundary
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./DiffusionFluxBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = DiffusionFluxBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./DirichletBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    seed                         = 0                           # The seed for the master random number generator
    type                         = DirichletBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = (required)                  # Value of the BC
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./EFieldBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = EFieldBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
    x_boundary_e_field           = (required)                  # The value of the electric field at the boundary in the x direction.
    y_boundary_e_field           = 0                           # The value of the electric field at the boundary in the y direction.
    z_boundary_e_field           = 0                           # The value of the electric field at the boundary in the z direction.
  [../]

  [./FunctionDirichletBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    function                     = (required)                  # The forcing function.
    seed                         = 0                           # The seed for the master random number generator
    type                         = FunctionDirichletBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./FunctionNeumannBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    function                     = (required)                  # The function.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = FunctionNeumannBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./FunctionPresetBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    function                     = (required)                  # The forcing function.
    seed                         = 0                           # The seed for the master random number generator
    type                         = FunctionPresetBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./MatchedValueBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    seed                         = 0                           # The seed for the master random number generator
    type                         = MatchedValueBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    v                            = (required)                  # The variable whose value we are to match.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./NeumannBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = NeumannBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = 0                           # The value of the gradient on the boundary.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./NoDiffusiveFlux]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = NoDiffusiveFlux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./OneDEqualValueConstraintBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    component                    = (required)                  # Component of the Lagrange multiplier
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    lambda                       = (required)                  # Lagrange multiplier
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = OneDEqualValueConstraintBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
    vg                           = (required)                  # Variation of the constraint g wrt this surface (+1 or -1). Note: g = ...
                                                               # value1 - value2 = 0 
  [../]

  [./Periodic]

    [./*]
      active                     = __all__                     # If specified only the blocks named will be visited and made active
      auto_direction             =                             # If using a generated mesh, you can specifiy just the dimension(s) you ...
                                                               # want to mark as periodic
      inv_transform_func         =                             # Functions that specify the inverse transformation
      primary                    =                             # Boundary ID associated with the primary boundary.
      secondary                  =                             # Boundary ID associated with the secondary boundary.
      transform_func             =                             # Functions that specify the transformation
      translation                =                             # Vector that translates coordinates on the primary boundary to coordinates ...
                                                               # on the secondary boundary.
      variable                   =                             # Variable for the periodic boundary
    [../]
  [../]

  [./PhysicalElectronBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    ip                           = (required)                  # The ion density
    reflection_coeff             = 0                           # The reflection coefficient for electrons at the walls.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    se_coeff                     = 0.1                         # The secondary electron emission coefficient for the walls.
    seed                         = 0                           # The seed for the master random number generator
    type                         = PhysicalElectronBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./PhysicalElectronEnergyBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    potential                    = (required)                  # The gradient of the potential will be used to compute the advection velocity.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = PhysicalElectronEnergyBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./PhysicalIonBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    reflection_coeff             = 0                           # The reflection coefficient for ions at the walls.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = PhysicalIonBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./PostprocessorDirichletBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    postprocessor                = (required)                  # The postprocessor to set the value to on the boundary.
    seed                         = 0                           # The seed for the master random number generator
    type                         = PostprocessorDirichletBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./PresetBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    seed                         = 0                           # The seed for the master random number generator
    type                         = PresetBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = (required)                  # Value of the BC
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SimpleNetFluxBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = SimpleNetFluxBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
    x_boundary_species_current   = (required)                  # The value of the species current at the boundary in the x direction.
    y_boundary_species_current   = 0                           # The value of the species current at the boundary in the y direction.
    z_boundary_species_current   = 0                           # The value of the species current at the boundary in the z direction.
  [../]

  [./SinDirichletBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    duration                     = 0
    final                        = 0
    initial                      = 0
    seed                         = 0                           # The seed for the master random number generator
    type                         = SinDirichletBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SinNeumannBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    duration                     = 0                           # The duration of the ramp
    final                        = 0                           # The final value of the gradient on the boundary
    initial                      = 0                           # The initial value of the gradient on the boundary
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = SinNeumannBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SometimesAdvectionBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = SometimesAdvectionBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
    velocity_function            = (required)                  # the name of the velocity function to utilize
  [../]

  [./SpeciesNetFluxBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    species_charge               = (required)                  # Specifies the charge of the species in question. Can be positive or negative.
    type                         = SpeciesNetFluxBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
    x_boundary_species_current   = (required)                  # The value of the species current at the boundary in the x direction.
    y_boundary_species_current   = 0                           # The value of the species current at the boundary in the y direction.
    z_boundary_species_current   = 0                           # The value of the species current at the boundary in the z direction.
  [../]

  [./VacuumBC]
    alpha                        = 1                           # No idea.
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = VacuumBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./VectorNeumannBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = VectorNeumannBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
    vector_value                 = '(x,y,z)=(       0,        0,        0)'# vector this BC should act in
  [../]

  [./WeakGradientBC]
    boundary                     = (required)                  # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal jacobian ...
                                                               # contributions to.  Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = WeakGradientBC
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]
[]

[Bounds]
  active                         = __all__                     # If specified only the blocks named will be visited and made active

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./AdvectiveFlux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    electron_density             = (required)                  # The electron density.
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    mobility                     = (required)                  # What mobility to use
    potential                    = (required)                  # The gradient of the potential will be used to compute the advection velocity.
    seed                         = 0                           # The seed for the master random number generator
    type                         = AdvectiveFlux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./AlphaTimesHSize]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    potential                    = (required)                  # The potential
    seed                         = 0                           # The seed for the master random number generator
    type                         = AlphaTimesHSize
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./BoundsAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    bounded_variable             = (required)                  # The variable to be bounded
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    lower                        =                             # The lower bound for the variable
    seed                         = 0                           # The seed for the master random number generator
    type                         = BoundsAux
    upper                        =                             # The upper bound for the variable
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./ChargeDensity]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    electron_density             = (required)                  # The electron density
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    ion_density                  = (required)                  # The ion density
    seed                         = 0                           # The seed for the master random number generator
    type                         = ChargeDensity
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./ConstantAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = ConstantAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = 0                           # Some constant value that can be read from the input file
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./DebugResidualAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    debug_variable               = (required)                  # The variable that is being debugged.
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = DebugResidualAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./DiffusiveFlux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diffusivity                  = (required)                  # What diffusivity to use
    electron_density             = (required)                  # The electron density.
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = DiffusiveFlux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./EFieldMag]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    potential                    = (required)                  # The potential
    seed                         = 0                           # The seed for the master random number generator
    type                         = EFieldMag
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./Ex]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    potential                    = (required)                  # The potential
    seed                         = 0                           # The seed for the master random number generator
    type                         = Ex
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./FunctionAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The function to use as the value
    seed                         = 0                           # The seed for the master random number generator
    type                         = FunctionAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./GapValueAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    normal_smoothing_distance    =                             # Distance from edge in parametric coordinates over which to smooth contact ...
                                                               # normal
    normal_smoothing_method      =                             # Method to use to smooth normals (edge_based|nodal_normal_based)
    order                        = FIRST                       # The finite element order
    paired_boundary              = (required)                  # The boundary on the other side of a gap.
    paired_variable              = (required)                  # The variable to get the value of.
    seed                         = 0                           # The seed for the master random number generator
    tangential_tolerance         =                             # Tangential distance to extend edges of contact surfaces
    type                         = GapValueAux
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
    warnings                     = 0                           # Whether to output warning messages concerning nodes not being found
  [../]

  [./HSize]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = HSize
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./IonSrcTerm]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    electron_density             = (required)                  # The electron density
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    potential                    = (required)                  # The potential
    seed                         = 0                           # The seed for the master random number generator
    type                         = IonSrcTerm
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialRealAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialRealAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialRealDenseMatrixAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    column                       = 0                           # The column component to consider for this kernel
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    row                          = 0                           # The row component to consider for this kernel
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialRealDenseMatrixAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialRealTensorValueAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    column                       = 0                           # The column component to consider for this kernel
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    row                          = 0                           # The row component to consider for this kernel
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialRealTensorValueAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialRealVectorValueAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    component                    = 0                           # The vector component to consider for this kernel
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialRealVectorValueAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./MaterialStdVectorAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    factor                       = 1                           # The factor by which to multiply your material property for visualization
    index                        = 0                           # The index to consider for this kernel
    offset                       = 0                           # The offset to add to your material property for visualization
    property                     = (required)                  # The scalar material property name
    seed                         = 0                           # The seed for the master random number generator
    type                         = MaterialStdVectorAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./NearestNodeDistanceAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    paired_boundary              = (required)                  # The boundary to find the distance to.
    seed                         = 0                           # The seed for the master random number generator
    type                         = NearestNodeDistanceAux
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./NearestNodeValueAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    paired_boundary              = (required)                  # The boundary to get the value from.
    paired_variable              = (required)                  # The variable to get the value of.
    seed                         = 0                           # The seed for the master random number generator
    type                         = NearestNodeValueAux
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./NormalizationAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    normal_factor                = 1                           # The normalization factor
    normalization                = (required)                  # The postprocessor on the source
    seed                         = 0                           # The seed for the master random number generator
    source_variable              = (required)                  # The variable to be normalized
    type                         = NormalizationAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./ParsedAux]
    args                         =                             # coupled variables
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    constant_expressions         =                             # Vector of values for the constants in constant_names (can be an FParser ...
                                                               # expression)
    constant_names               =                             # Vector of constants used in the parsed function (use this for kB etc.)
    disable_fpoptimizer          = 0                           # Disable the function parser algebraic optimizer
    enable_jit                   = 1                           # enable just-in-time compilation of function expressions for faster evaluation
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    fail_on_evalerror            = 0                           # Fail fatally if a function evaluation returns an error code (otherwise ...
                                                               # just pass on NaN)
    function                     = (required)                  # function expression
    seed                         = 0                           # The seed for the master random number generator
    type                         = ParsedAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./PenetrationAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    normal_smoothing_distance    =                             # Distance from edge in parametric coordinates over which to smooth contact ...
                                                               # normal
    normal_smoothing_method      =                             # Method to use to smooth normals (edge_based|nodal_normal_based)
    order                        = FIRST                       # The finite element order
    paired_boundary              = (required)                  # The boundary to be penetrated
    quantity                     = distance                    # The quantity to recover from the available penetration information
    seed                         = 0                           # The seed for the master random number generator
    tangential_tolerance         =                             # Tangential distance to extend edges of contact surfaces
    type                         = PenetrationAux
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./ProcessorIDAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = ProcessorIDAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./QuotientAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    denominator                  =                             # The downstairs of the quotient variable
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    numerator                    =                             # The upstairs of the quotient variable
    seed                         = 0                           # The seed for the master random number generator
    type                         = QuotientAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./SelfAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = SelfAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./Sigma]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    some_var                     = (required)                  # The advected variable needed for determining tau.
    type                         = Sigma
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./SolutionAux]
    add_factor                   = 0                           # Add this value (b) to the solution (x): ax+b, where a is the 'scale_factor'
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    direct                       = 0                           # If true the meshes must be the same and then the values are simply copied ...
                                                               # over.
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    from_variable                =                             # The name of the variable to extract from the file
    scale_factor                 = 1                           # Scale factor (a)  to be applied to the solution (x): ax+b, where b is ...
                                                               # the 'add_factor'
    seed                         = 0                           # The seed for the master random number generator
    solution                     = (required)                  # The name of the SolutionUserObject
    type                         = SolutionAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./SpatialUserObjectAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = SpatialUserObjectAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    user_object                  = (required)                  # The UserObject UserObject to get values from.  Note that the UserObject ...
                                                               # _must_ implement the spatialValue() virtual function!
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./VariableGradientComponent]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    component                    =                             # The gradient component to compute
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    gradient_variable            = (required)                  # The variable from which to compute the gradient component
    seed                         = 0                           # The seed for the master random number generator
    type                         = VariableGradientComponent
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./VectorMagnitudeAux]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = VectorMagnitudeAux
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
    x                            = (required)                  # x-component of the vector
    y                            =                             # y-component of the vector
    z                            =                             # z-component of the vector
  [../]

  [./Velocity]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    some_var                     = (required)                  # The advected variable needed for determining tau.
    type                         = Velocity
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./VelocityH]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    some_var                     = (required)                  # The advected variable needed for determining tau.
    type                         = VelocityH
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]

  [./VelocityMag]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = VelocityMag
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object applies to
  [../]
[]

[Constraints]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./CoupledTiedValueConstraint]
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    master                       = (required)                  # The boundary ID associated with the master side
    master_variable              = (required)                  # The variable on the master side of the domain
    normal_smoothing_distance    =                             # Distance from edge in parametric coordinates over which to smooth contact ...
                                                               # normal
    normal_smoothing_method      =                             # Method to use to smooth normals (edge_based|nodal_normal_based)
    order                        = FIRST                       # The finite element order used for projections
    scaling                      = 1                           # scaling factor to be applied to constraint equations
    slave                        = (required)                  # The boundary ID associated with the slave side
    tangential_tolerance         =                             # Tangential distance to extend edges of contact surfaces
    type                         = CoupledTiedValueConstraint
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this constraint is applied to.
  [../]

  [./EqualValueBoundaryConstraint]
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    master                       = (required)                  # The ID of the master node
    penalty                      = (required)                  # The penalty used for the boundary term
    slave                        = (required)                  # The boundary ID associated with the slave side
    type                         = EqualValueBoundaryConstraint
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this constraint is applied to.
  [../]

  [./EqualValueConstraint]
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    interface                    = (required)                  # The name of the interface.
    master_variable              = (required)                  # Variable on master surface
    slave_variable               =                             # Variable on master surface
    type                         = EqualValueConstraint
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this constraint is applied to.
  [../]

  [./TiedValueConstraint]
    execute_on                   = LINEAR                      # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    master                       = (required)                  # The boundary ID associated with the master side
    master_variable              = (required)                  # The variable on the master side of the domain
    normal_smoothing_distance    =                             # Distance from edge in parametric coordinates over which to smooth contact ...
                                                               # normal
    normal_smoothing_method      =                             # Method to use to smooth normals (edge_based|nodal_normal_based)
    order                        = FIRST                       # The finite element order used for projections
    scaling                      = 1                           # scaling factor to be applied to constraint equations
    slave                        = (required)                  # The boundary ID associated with the slave side
    tangential_tolerance         =                             # Tangential distance to extend edges of contact surfaces
    type                         = TiedValueConstraint
    use_displaced_mesh           = 1                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this constraint is applied to.
  [../]
[]

[DGKernels]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./DGDiffusion]
    epsilon                      = (required)                  # epsilon
    sigma                        = (required)                  # sigma
    type                         = DGDiffusion
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]
[]

[Dampers]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./ConstantDamper]
    damping                      = (required)                  # The percentage (between 0 and 1) of the newton update to take.
    type                         = ConstantDamper
    variable                     = (required)                  # The name of the variable that this damper operates on
  [../]

  [./MaxIncrement]
    max_increment                = (required)                  # The maximum newton increment for the variable.
    type                         = MaxIncrement
    variable                     = (required)                  # The name of the variable that this damper operates on
  [../]
[]

[Debug]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  show_actions                   = 0                           # Print out the actions being executed
  show_material_props            = 0                           # Print out the material properties supplied for each block, face, neighbor, ...
                                                               # and/or sideset
  show_parser                    = 0                           # Shows parser block extraction and debugging information
  show_top_residuals             = 0                           # The number of top residuals to print out (0 = no output)
  show_var_residual_norms        = 0                           # Print the residual norms of the individual solution variables at each ...
                                                               # nonlinear iteration
  show_var_residual              =                             # Variables for which residuals will be sent to the output file
[]

[DeprecatedBlock]
  DEPRECATED                     =                             # *** WARNING: This block is deprecated - DO NOT USE ***
  active                         = __all__                     # If specified only the blocks named will be visited and made active
[]

[DiracKernels]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./ConstantPointSource]
    point                        = (required)                  # The x,y,z coordinates of the point
    type                         = ConstantPointSource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = (required)                  # The value of the point source
    variable                     = (required)                  # The name of the variable that this kernel operates on
  [../]
[]

[Executioner]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  compute_initial_residual_before_preset_bcs = 0                           # Use the residual norm computed *before* PresetBCs are imposed in relative ...
                                                               # convergence check
  l_abs_step_tol                 = -1                          # Linear Absolute Step Tolerance
  l_max_its                      = 10000                       # Max Linear Iterations
  l_tol                          = 1e-05                       # Linear Tolerance
  line_search                    = default                     # Specifies the line search type (Note: none = basic)
  nl_abs_step_tol                = 1e-50                       # Nonlinear Absolute step Tolerance
  nl_abs_tol                     = 1e-50                       # Nonlinear Absolute Tolerance
  nl_max_funcs                   = 10000                       # Max Nonlinear solver function evaluations
  nl_max_its                     = 50                          # Max Nonlinear Iterations
  nl_rel_step_tol                = 1e-50                       # Nonlinear Relative step Tolerance
  nl_rel_tol                     = 1e-08                       # Nonlinear Relative Tolerance
  no_fe_reinit                   = 0                           # Specifies whether or not to reinitialize FEs
  petsc_options                  =                             # Singleton PETSc options
  petsc_options_iname            =                             # Names of PETSc name/value pairs
  petsc_options_value            =                             # Values of PETSc name/value pairs (must correspond with "petsc_options_iname"
  solve_type                     =                             # PJFNK: Preconditioned Jacobian-Free Newton Krylov JFNK: Jacobian-Free ...
                                                               # Newton Krylov NEWTON: Full Newton Solve FD: Use finite differences to ...
                                                               # compute Jacobian LINEAR: Solving a linear problem

  [./<type>]

    [./InversePowerMethod]
      Chebyshev_acceleration_on  = 1                           # If Chebyshev acceleration is turned on
      auto_initialization        = 1                           # True to ask the solver to set initial
      bx_norm                    = (required)                  # To evaluate |Bx| for the eigenvalue
      eig_check_tol              = 1e-06                       # Eigenvalue convergence tolerance
      k0                         = 1                           # Initial guess of the eigenvalue
      max_power_iterations       = 300                         # The maximum number of power iterations
      min_power_iterations       = 1                           # Minimum number of power iterations
      normal_factor              =                             # Normalize x to make |x| equal to this factor
      normalization              =                             # To evaluate |x| for normalization
      output_before_normalization = 1                           # True to output a step before normalization
      pfactor                    = 0.01                        # Reduce residual norm per power iteration by this factor
      restart_file_base          =                             # File base name used for restart
      sol_check_tol              = 1.79769e+308                # Convergence tolerance on |x-x_previous| when provided
      splitting                  =                             # Top-level splitting defining a hierarchical decomposition into subsystems ...
                                                               # to help the solver.
      time                       = 0                           # System time
      type                       = InversePowerMethod
      xdiff                      =                             # To evaluate |x-x_previous| for power iterations
    [../]

    [./NonlinearEigen]
      auto_initialization        = 1                           # True to ask the solver to set initial
      bx_norm                    = (required)                  # To evaluate |Bx| for the eigenvalue
      free_power_iterations      = 4                           # The number of free power iterations
      k0                         = 1                           # Initial guess of the eigenvalue
      normal_factor              =                             # Normalize x to make |x| equal to this factor
      normalization              =                             # To evaluate |x| for normalization
      output_after_power_iterations = 1                           # True to output solution after free power iterations
      output_before_normalization = 1                           # True to output a step before normalization
      pfactor                    = 0.01                        # The factor of residual to be reduced per free power iteration or per ...
                                                               # nonlinear step
      restart_file_base          =                             # File base name used for restart
      source_abs_tol             = 1e-06                       # Absolute tolernance on residual norm
      source_rel_tol             = 1e-50                       # Relative tolernance on residual norm after free power iterations
      splitting                  =                             # Top-level splitting defining a hierarchical decomposition into subsystems ...
                                                               # to help the solver.
      time                       = 0                           # System time
      type                       = NonlinearEigen
    [../]

    [./Steady]
      restart_file_base          =                             # File base name used for restart
      splitting                  =                             # Top-level splitting defining a hierarchical decomposition into subsystems ...
                                                               # to help the solver.
      type                       = Steady
    [../]

    [./Transient]
      abort_on_solve_fail        = 0                           # abort if solve not converged rather than cut timestep
      dt                         = 1                           # The timestep size between solves
      dtmax                      = 1e+30                       # The maximum timestep size in an adaptive run
      dtmin                      = 2e-14                       # The minimum timestep size in an adaptive run
      end_time                   = 1e+30                       # The end time of the simulation
      n_startup_steps            = 0                           # The number of timesteps during startup
      num_steps                  = 4294967295                  # The number of timesteps in a transient run
      picard_abs_tol             = 1e-50                       # The absolute nonlinear residual to shoot for during Picard iterations. ...
                                                               # This check is performed based on the Master app's nonlinear residual.
      picard_max_its             = 1                           # Number of times each timestep will be solved.  Mainly used when wanting ...
                                                               # to do Picard iterations with MultiApps that are set to execute_on timestep_end ...
                                                               # or timestep_begin
      picard_rel_tol             = 1e-08                       # The relative nonlinear residual drop to shoot for during Picard iterations. ...
                                                               # This check is performed based on the Master app's nonlinear residual.
      predictor_scale            =                             # The scale factor for the predictor (can range from 0 to 1)
      reset_dt                   = 0                           # Use when restarting a calculation to force a change in dt.
      restart_file_base          =                             # File base name used for restart
      scheme                     = implicit-euler              # Time integration scheme used.
      splitting                  =                             # Top-level splitting defining a hierarchical decomposition into subsystems ...
                                                               # to help the solver.
      ss_check_tol               = 1e-08                       # Whenever the relative residual changes by less than this the solution ...
                                                               # will be considered to be at steady state.
      ss_tmin                    = 0                           # Minimum number of timesteps to take before checking for steady state ...
                                                               # conditions.
      start_time                 = 0                           # The start time of the simulation
      time_period_ends           =                             # The end times of time periods
      time_period_starts         =                             # The start times of time periods
      time_periods               =                             # The names of periods
      timestep_tolerance         = 2e-14                       # the tolerance setting for final timestep size and sync times
      trans_ss_check             = 0                           # Whether or not to check for steady state conditions
      type                       = Transient
      use_multiapp_dt            = 0                           # If true then the dt for the simulation will be chosen by the MultiApps. ...
                                                               # If false (the default) then the minimum over the master dt and the MultiApps ...
                                                               # is used
      verbose                    = 0                           # Print detailed diagnostics on timestep calculation
    [../]
  [../]

  [./Adaptivity]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
    coarsen_fraction             = 0                           # The fraction of elements or error to coarsen. Should be between 0 and ...
                                                               # 1.
    cycles_per_step              = 1                           # The number of adaptivity cycles per step
    error_estimator              = KellyErrorEstimator         # The class name of the error estimator you want to use.
    initial_adaptivity           = 0                           # The number of adaptivity steps to perform using the initial conditions
    max_h_level                  = 0                           # Maximum number of times a single element can be refined. If 0 then infinite.
    print_changed_info           = 0                           # Determines whether information about the mesh is printed when adaptivity ...
                                                               # occurs
    refine_fraction              = 0                           # The fraction of elements or error to refine. Should be between 0 and ...
                                                               # 1.
    show_initial_progress        = 1                           # Show the progress of the initial adaptivity
    start_time                   = -1.79769e+308               # The time that adaptivity will be active after.
    steps                        = 0                           # The number of adaptivity steps to perform at any one time for steady ...
                                                               # state
    stop_time                    = 1.79769e+308                # The time after which adaptivity will no longer be active.
    weight_names                 =                             # List of names of variables that will be associated with weight_values
    weight_values                =                             # List of values between 0 and 1 to weight the associated weight_names ...
                                                               # error by
  [../]

  [./Predictor]
    active                       = __all__                     # If specified only the blocks named will be visited and made active

    [./<type>]

      [./AdamsPredictor]
        order                    = 2                           # The maximum reachable order of the Adams-Bashforth Predictor
        scale                    = (required)                  # The scale factor for the predictor (can range from 0 to 1)
        type                     = AdamsPredictor
      [../]

      [./SimplePredictor]
        scale                    = (required)                  # The scale factor for the predictor (can range from 0 to 1)
        type                     = SimplePredictor
      [../]
    [../]
  [../]

  [./Quadrature]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
    element_order                = AUTO                        # Order of the quadrature for elements
    order                        = AUTO                        # Order of the quadrature
    side_order                   = AUTO                        # Order of the quadrature for sides
    type                         = GAUSS                       # Type of the quadrature rule
  [../]

  [./TimePeriods]

    [./*]
      active                     = __all__                     # If specified only the blocks named will be visited and made active
      active_bcs                 =                             # The list of active boundary conditions during this time period (must ...
                                                               # not be used with "inactive_bcs")
      active_kernels             =                             # The list of active kernels during this time period (must not be used ...
                                                               # with "inactive_kernels")
      inactive_bcs               =                             # The list of inactive boundary conditions during this time period (must ...
                                                               # not be used with "active_bcs")
      inactive_kernels           =                             # The list of inactive kernels during this time period (must not be used ...
                                                               # with "active_kernels")
      start                      = 0                           # The start time for this time period
    [../]
  [../]

  [./TimeStepper]
    active                       = __all__                     # If specified only the blocks named will be visited and made active

    [./<type>]

      [./AB2PredictorCorrector]
        dt                       = (required)                  # Initial time step size
        e_max                    = (required)                  # Maximum acceptable error.
        e_tol                    = (required)                  # Target error tolerance.
        max_increase             = 1e+09                       # Maximum ratio that the time step can increase.
        reset_dt                 = 0                           # Use when restarting a calculation to force a change in dt.
        scaling_parameter        = 0.8                         # scaling parameter for dt selection
        start_adapting           = 2                           # when to start taking adaptive time steps
        steps_between_increase   = 1                           # the number of time steps before recalculating dt
        type                     = AB2PredictorCorrector
      [../]

      [./ConstantDT]
        dt                       = (required)                  # Size of the time step
        growth_factor            = 2                           # Maximum ratio of new to previous timestep sizes following a step that ...
                                                               # required the time step to be cut due to a failed solve.
        reset_dt                 = 0                           # Use when restarting a calculation to force a change in dt.
        type                     = ConstantDT
      [../]

      [./DT2]
        dt                       = 1                           # The initial time step size.
        e_max                    = (required)                  # Maximum acceptable error.
        e_tol                    = (required)                  # Target error tolerance.
        max_increase             = 1e+09                       # Maximum ratio that the time step can increase.
        reset_dt                 = 0                           # Use when restarting a calculation to force a change in dt.
        type                     = DT2
      [../]

      [./FunctionDT]
        growth_factor            = 2                           # Maximum ratio of new to previous timestep sizes following a step that ...
                                                               # required the time step to be cut due to a failed solve.
        min_dt                   = 0                           # The minimal dt to take.
        reset_dt                 = 0                           # Use when restarting a calculation to force a change in dt.
        time_dt                  =                             # The values of dt
        time_t                   =                             # The values of t
        type                     = FunctionDT
      [../]

      [./IterationAdaptiveDT]
        cutback_factor           = 0.5                         # Factor to apply to timestep if difficult convergence (if 'optimal_iterations' ...
                                                               # is specified) or if solution failed.
        dt                       = (required)                  # The default timestep size between solves
        force_step_every_function_point = 0                           # Forces the timestepper to take a step that is consistent with points ...
                                                               # defined in the function.
        growth_factor            = 2                           # Factor to apply to timestep if easy convergence (if 'optimal_iterations' ...
                                                               # is specified) or if recovering from failed solve
        iteration_window         =                             # The size of the nonlinear iteration window for adaptive timestepping ...
                                                               # (default = 0.2*optimal_iterations)
        linear_iteration_ratio   =                             # The ratio of linear to nonlinear iterations to determine target linear ...
                                                               # iterations and window for adaptive timestepping (default = 25)
        max_function_change      =                             # The absolute value of the maximum change in timestep_limiting_function ...
                                                               # over a timestep
        optimal_iterations       =                             # The target number of nonlinear iterations for adaptive timestepping
        reset_dt                 = 0                           # Use when restarting a calculation to force a change in dt.
        time_dt                  =                             # The values of dt
        time_t                   =                             # The values of t
        timestep_limiting_function =                             # A function used to control the timestep by limiting the change in the ...
                                                               # function over a timestep
        type                     = IterationAdaptiveDT
      [../]

      [./PostprocessorDT]
        dt                       =                             # Initial value of dt
        postprocessor            = (required)                  # The name of the postprocessor that computes the dt
        reset_dt                 = 0                           # Use when restarting a calculation to force a change in dt.
        type                     = PostprocessorDT
      [../]

      [./SolutionTimeAdaptiveDT]
        adapt_log                = 0                           # Output adaptive time step log
        dt                       = (required)                  # The timestep size between solves
        initial_direction        = 1                           # Direction for the first step.  1 for up... -1 for down. 
        percent_change           = 0.1                         # Percentage to change the timestep by.  Should be between 0 and 1
        reset_dt                 = 0                           # Use when restarting a calculation to force a change in dt.
        type                     = SolutionTimeAdaptiveDT
      [../]
    [../]
  [../]
[]

[Functions]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./Axisymmetric2D3DSolutionFunction]
    2d_axis_point1               = '(x,y,z)=(       0,        0,        0)'# Start point for axis of symmetry for the 2d model
    2d_axis_point2               = '(x,y,z)=(       0,        1,        0)'# End point for axis of symmetry for the 2d model
    3d_axis_point1               = '(x,y,z)=(       0,        0,        0)'# Start point for axis of symmetry for the 3d model
    3d_axis_point2               = '(x,y,z)=(       0,        1,        0)'# End point for axis of symmetry for the 3d model
    add_factor                   = 0                           # Add this value (b) to the solution (x): ax+b, where a is the 'scale_factor'
    component                    =                             # Component of the variable to be computed if it is a vector
    from_variables               =                             # The names of the variables in the file that are to be extracted, in x, ...
                                                               # y order if they are vector components
    scale_factor                 = 1                           # Scale factor (a) to be applied to the solution (x): ax+b, where b is ...
                                                               # the 'add_factor'
    solution                     = (required)                  # The SolutionUserObject to extract data from.
    type                         = Axisymmetric2D3DSolutionFunction
  [../]

  [./CompositeFunction]
    functions                    =                             # The functions to be multiplied together.
    scale_factor                 = 1                           # Scale factor to be applied to the ordinate values
    type                         = CompositeFunction
  [../]

  [./ConstantFunction]
    type                         = ConstantFunction
    value                        = 0                           # The constant value
  [../]

  [./LinearCombinationFunction]
    functions                    = (required)                  # This function will return Sum_over_i(w_i * functions_i)
    type                         = LinearCombinationFunction
    w                            = (required)                  # This function will return Sum_over_i(w_i * functions_i)
  [../]

  [./ParsedFunction]
    type                         = ParsedFunction
    vals                         =                             # Constant numeric values or postprocessor names for vars.
    value                        = (required)                  # The user defined function.
    vars                         =                             # The constant variables (excluding t,x,y,z) in the forcing function.
  [../]

  [./ParsedGradFunction]
    grad_x                       = 0                           # Partial with respect to x.
    grad_y                       = 0                           # Partial with respect to y.
    grad_z                       = 0                           # Partial with respect to z.
    type                         = ParsedGradFunction
    vals                         =                             # Constant numeric values or postprocessor names for vars.
    value                        = 0                           # User defined function.
    vars                         =                             # The constant variables (excluding t,x,y,z) in the forcing function.
  [../]

  [./ParsedVectorFunction]
    type                         = ParsedVectorFunction
    vals                         =                             # Constant numeric values or postprocessor names for vars.
    value_x                      = 0                           # x-component of function.
    value_y                      = 0                           # y-component of function.
    value_z                      = 0                           # z-component of function.
    vars                         =                             # The constant variables (excluding t,x,y,z) in the forcing function.
  [../]

  [./PiecewiseBilinear]
    axis                         = -1                          # The axis used (0, 1, or 2 for x, y, or z).
    data_file                    =                             # File holding csv data for use with PiecewiseBilinear
    radial                       = 0                           # Set to true if you want to interpolate along a radius rather that along ...
                                                               # a specific axis, and note that you have to define xaxis and yaxis in ...
                                                               # the input file
    scale_factor                 = 1                           # Scale factor to be applied to the axis, yaxis, or xaxis values
    type                         = PiecewiseBilinear
    xaxis                        = -1                          # The coordinate used for x-axis data (0, 1, or 2 for x, y, or z).
    yaxis                        = -1                          # The coordinate used for y-axis data (0, 1, or 2 for x, y, or z).
  [../]

  [./PiecewiseConstant]
    axis                         =                             # The axis used (0, 1, or 2 for x, y, or z) if this is to be a function ...
                                                               # of position
    data_file                    =                             # File holding csv data for use with Piecewise
    direction                    = left                        # Direction to look to find value: left right
    format                       = rows                        # Format of csv data file that is in either in columns or rows
    scale_factor                 = 1                           # Scale factor to be applied to the ordinate values
    type                         = PiecewiseConstant
    x                            =                             # The abscissa values
    xy_data                      =                             # All function data, supplied in abscissa, ordinate pairs
    y                            =                             # The ordinate values
  [../]

  [./PiecewiseLinear]
    axis                         =                             # The axis used (0, 1, or 2 for x, y, or z) if this is to be a function ...
                                                               # of position
    data_file                    =                             # File holding csv data for use with Piecewise
    format                       = rows                        # Format of csv data file that is in either in columns or rows
    scale_factor                 = 1                           # Scale factor to be applied to the ordinate values
    type                         = PiecewiseLinear
    x                            =                             # The abscissa values
    xy_data                      =                             # All function data, supplied in abscissa, ordinate pairs
    y                            =                             # The ordinate values
  [../]

  [./PiecewiseLinearFile]
    axis                         =                             # The axis used (0, 1, or 2 for x, y, or z) if this is to be a function ...
                                                               # of position
    data_file                    =                             # File holding csv data for use with Piecewise
    format                       = rows                        # Format of csv data file that is in either in columns or rows
    scale_factor                 = 1                           # Scale factor to be applied to the ordinate values
    type                         = PiecewiseLinearFile
    x                            =                             # The abscissa values
    xy_data                      =                             # All function data, supplied in abscissa, ordinate pairs
    y                            =                             # The ordinate values
  [../]

  [./PiecewiseMultilinear]
    data_file                    =                             # File holding data for use with PiecewiseMultilinear.  Format: any empty ...
                                                               # line and any line beginning with # are ignored, all other lines are assumed ...
                                                               # to contain relevant information.  The file must begin with specification ...
                                                               # of the grid.  This is done through lines containing the keywords: AXIS ...
                                                               # X; AXIS Y; AXIS Z; or AXIS T.  Immediately following the keyword line ...
                                                               # must be a space-separated line of real numbers which define the grid ...
                                                               # along the specified axis.  These data must be monotonically increasing. ...
                                                               # After all the axes and their grids have been specified, there must be ...
                                                               # a line that is DATA.  Following that line, function values are given ...
                                                               # in the correct order (they may be on indivicual lines, or be space-separated ...
                                                               # on a number of lines).  When the function is evaluated, f[i,j,k,l] corresponds ...
                                                               # to the i + j*Ni + k*Ni*Nj + l*Ni*Nj*Nk data value.  Here i>=0 corresponding ...
                                                               # to the index along the first AXIS, j>=0 corresponding to the index along ...
                                                               # the second AXIS, etc, and Ni = number of grid points along the first ...
                                                               # AXIS, etc.
    type                         = PiecewiseMultilinear
  [../]

  [./SolutionFunction]
    add_factor                   = 0                           # Add this value (b) to the solution (x): ax+b, where a is the 'scale_factor'
    from_variable                =                             # The name of the variable in the file that is to be extracted
    scale_factor                 = 1                           # Scale factor (a) to be applied to the solution (x): ax+b, where b is ...
                                                               # the 'add_factor'
    solution                     = (required)                  # The SolutionUserObject to extract data from.
    type                         = SolutionFunction
  [../]

  [./SplineFunction]
    type                         = SplineFunction
    x                            = (required)                  # The abscissa values
    y                            = (required)                  # The ordinate values
    yp1                          = 1e+30                       # The value of the first derivative of the interpolating function at point ...
                                                               # 1
    ypn                          = 1e+30                       # The value of the first derivative of the interpolating function at point ...
                                                               # n
  [../]
[]

[GlobalParams]
[]

[ICs]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./BoundingBoxIC]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    inside                       = 0                           # The value of the variable inside the box
    outside                      = 0                           # The value of the variable outside the box
    type                         = BoundingBoxIC
    variable                     = (required)                  # The variable this initial condition is supposed to provide values for.
    x1                           = (required)                  # The x coordinate of the lower left-hand corner of the box
    x2                           = (required)                  # The x coordinate of the upper right-hand corner of the box
    y1                           = (required)                  # The y coordinate of the lower left-hand corner of the box
    y2                           = (required)                  # The y coordinate of the upper right-hand corner of the box
    z1                           = 0                           # The z coordinate of the lower left-hand corner of the box
    z2                           = 0                           # The z coordinate of the upper right-hand corner of the box
  [../]

  [./ConstantIC]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    type                         = ConstantIC
    value                        = (required)                  # The value to be set in IC
    variable                     = (required)                  # The variable this initial condition is supposed to provide values for.
  [../]

  [./FunctionIC]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    function                     = (required)                  # The initial condition function.
    type                         = FunctionIC
    variable                     = (required)                  # The variable this initial condition is supposed to provide values for.
  [../]

  [./RandomIC]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    max                          = 1                           # Upper bound of the randomly generated values
    min                          = 0                           # Lower bound of the randomly generated values
    seed                         = 0                           # Seed value for the random number generator
    type                         = RandomIC
    variable                     = (required)                  # The variable this initial condition is supposed to provide values for.
  [../]

  [./ScalarComponentIC]
    type                         = ScalarComponentIC
    values                       = (required)                  # Initial values to initialize the scalar variable.
    variable                     =                             # The variable this initial condition is supposed to provide values for.
  [../]

  [./ScalarConstantIC]
    type                         = ScalarConstantIC
    value                        = 0
    variable                     =                             # The variable this initial condition is supposed to provide values for.
  [../]
[]

[Kernels]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./AnisotropicDiffusion]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    tensor_coeff                 = (required)                  # The Tensor to multiply the Diffusion operator by
    type                         = AnisotropicDiffusion
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ArpSource]
    Ars                          = (required)                  # The excited state argon density in moles
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    em                           = (required)                  # The electron density
    mean_electron_energy         = (required)                  # The mean electron energy
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ArpSource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ArsSource]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    em                           = (required)                  # The electron density
    mean_electron_energy         = (required)                  # The mean electron energy
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ArsSource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ArtificialDiff]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    crosswind                    = 0                           # Whether to use crosswind stabilization
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    epsilon                      = 0                           # Parameter to prevent non-zero denominators
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ArtificialDiff
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./BodyForce]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    function                     = 1                           # A function that describes the body force
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = BodyForce
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = 0
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./CoeffDiffusion]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = CoeffDiffusion
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    var_name_string              = (required)                  # The name of the kernel variable. Required to import the correct diffusivity ...
                                                               # from the material properties file.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ConstConvection]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ConstConvection
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ConstConvectionSUPG]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ConstConvectionSUPG
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ConvectionArb]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ConvectionArb
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
    velocity_function            = (required)                  # the name of the velocity function to utilize
  [../]

  [./CoupledForce]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = CoupledForce
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    v                            = (required)                  # The coupled variable which provides the force
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./CoupledIonizationSource]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    electron_density             = (required)                  # electron density
    potential                    = (required)                  # The electrical potential
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = CoupledIonizationSource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./Diffusion]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = Diffusion
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./DivFreeConvection]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = DivFreeConvection
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./EFieldAdvection]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    potential                    = (required)                  # The gradient of the potential will be used to compute the advection velocity.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = EFieldAdvection
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    var_name_string              = (required)                  # The name of the kernel variable. Required to import the correct advection_coefficient ...
                                                               # from the material properties file.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ElectronDiffusion]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    mean_electron_energy         = (required)                  # The electron energy used to calculate the diffusivity using the Einstein ...
                                                               # relation
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElectronDiffusion
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ElectronEnergyDiffusion]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    em                           = (required)                  # The electron density used to calculate the diffusivity using the Einstein ...
                                                               # relation
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElectronEnergyDiffusion
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ElectronEnergySource]
    Ars                          = (required)                  # The excited state argon density in moles
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    em                           = (required)                  # The electron density, most likely in #/m^3
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElectronEnergySource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ElectronSource]
    Ars                          = (required)                  # The excited state argon density in moles
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    mean_electron_energy         = (required)                  # The mean electron energy needed to calculate Te
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElectronSource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./ExampleDiffusion]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = ExampleDiffusion
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./FirstOrderReaction]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    reaction_coeff               = (required)                  # The reaction coefficient of the medium
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = FirstOrderReaction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./INSMass]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    p                            = (required)                  # pressure
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = INSMass
    u                            = (required)                  # x-velocity
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    v                            =                             # y-velocity
    variable                     = (required)                  # The name of the variable that this Kernel operates on
    w                            =                             # z-velocity
  [../]

  [./INSMomentum]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    component                    = (required)                  # 0,1,2 depending on if we are solving the x,y,z component of the momentum ...
                                                               # equation
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    gravity                      = (required)                  # Direction of the gravity vector
    mu                           = (required)                  # dynamic viscosity
    p                            = (required)                  # pressure
    rho                          = (required)                  # density
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = INSMomentum
    u                            = (required)                  # x-velocity
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    v                            =                             # y-velocity
    variable                     = (required)                  # The name of the variable that this Kernel operates on
    w                            =                             # z-velocity
  [../]

  [./INSMomentumTimeDerivative]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    lumping                      = 0                           # True for mass matrix lumping, false otherwise
    rho                          = (required)                  # density
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = INSMomentumTimeDerivative
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./INSTemperature]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    cp                           = (required)                  # specific heat
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    k                            = (required)                  # thermal conductivity
    rho                          = (required)                  # density
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = INSTemperature
    u                            = (required)                  # x-velocity
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    v                            =                             # y-velocity
    variable                     = (required)                  # The name of the variable that this Kernel operates on
    w                            =                             # z-velocity
  [../]

  [./INSTemperatureTimeDerivative]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    cp                           = (required)                  # specific heat
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    lumping                      = 0                           # True for mass matrix lumping, false otherwise
    rho                          = (required)                  # density
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = INSTemperatureTimeDerivative
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./IonizationSource]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    potential                    = (required)                  # The electrical potential
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = IonizationSource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./JouleHeating]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    em                           = (required)                  # The electron density.
    potential                    = (required)                  # The gradient of the potential will be used to compute the advection velocity.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = JouleHeating
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./MassEigenKernel]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    eigen                        = 1                           # Use for eigenvalue problem (true) or source problem (false)
    eigen_postprocessor          = 1                           # The name of the postprocessor that provides the eigenvalue.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = MassEigenKernel
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./MatAdvection]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = MatAdvection
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./PoissonSource]
    Arp                          = (required)                  # Ion density in the simulation
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    em                           = (required)                  # Electron density in the simulation
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = PoissonSource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./PotentialDrivenArtificialDiff]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    consistent                   = 1                           # Whether to use crosswind stabilization
    delta                        = 0.5                         # Scaling parameter for artificial diffusivity
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    potential                    = (required)                  # The potential for calculating the advection velocity.
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = PotentialDrivenArtificialDiff
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    var_name_string              = (required)                  # The name of the kernel variable. Required to import the correct mobility ...
                                                               # from the material properties file.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./Reaction]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = Reaction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./RealPropertyOutput]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    prop_name                    = (required)                  # The Real material property you would like to output
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = RealPropertyOutput
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./SecondOrderReaction]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    reactant_two                 = (required)                  # The reactant reacting with the equations variable
    reaction_coeff               = (required)                  # The reaction coefficient of the medium
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = SecondOrderReaction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./SelfBinaryReaction]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    reaction_coeff               = (required)                  # The reaction coefficient of the medium
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = SelfBinaryReaction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./Source]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = Source
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    var_name_string              = (required)                  # The name of the kernel variable. Required to import the correct source ...
                                                               # and on-diagonal Jacobian term from the material properties file
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./SrcSecondOrderReaction]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    reactant1                    = (required)                  # Reactant 1
    reactant2                    = (required)                  # Reactant 2
    reaction_coeff               = (required)                  # The reaction coefficient for this reaction
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    stoich_coeff                 = (required)                  # The stoichiometric gain/loss coefficient for this specie
    type                         = SrcSecondOrderReaction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./SrcSelfBinaryReaction]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    reaction_coeff               = (required)                  # The reaction coefficient for this reaction
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    sole_reactant                = (required)                  # The reactant undergoing reaction with itself to produce the variable ...
                                                               # specie
    stoich_coeff                 = (required)                  # The stoichiometric gain/loss coefficient for this specie
    type                         = SrcSelfBinaryReaction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./TimeDerivative]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    lumping                      = 0                           # True for mass matrix lumping, false otherwise
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = TimeDerivative
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./TimeDerivativeElectronTemp]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    em                           =                             # The electron density
    lumping                      = 0                           # True for mass matrix lumping, false otherwise
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = TimeDerivativeElectronTemp
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./TimeDerivativeSUPG]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    crosswind                    = 0                           # True if you want to include crosswind diffusion
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    epsilon                      = 0                           # To prevent denominators from being zero
    lumping                      = 0                           # True for mass matrix lumping, false otherwise
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = TimeDerivativeSUPG
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./UnitySource]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = UnitySource
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]

  [./UserForcingFunction]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    diag_save_in                 =                             # The name of auxiliary variables to save this Kernel's diagonal Jacobian ...
                                                               # contributions to. Everything about that variable must match everything ...
                                                               # about this variable (the type, what blocks it's on, etc.)
    function                     = (required)                  # The forcing function
    save_in                      =                             # The name of auxiliary variables to save this Kernel's residual contributions ...
                                                               # to.  Everything about that variable must match everything about this ...
                                                               # variable (the type, what blocks it's on, etc.)
    seed                         = 0                           # The seed for the master random number generator
    type                         = UserForcingFunction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this Kernel operates on
  [../]
[]

[LotsOfCoeffDiffusion]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  block                          =                             # The block id where this variable lives
  eigen                          = 0                           # True to make this variable an eigen variable
  family                         = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
  initial_condition              = 0                           # Specifies the initial condition for this variable
  order                          = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
  outputs                        =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
  scaling                        = 1                           # Specifies a scaling factor to apply to this variable
  variables                      = (required)                  # The names of the variables for which CoeffDiffusion kernels should be ...
                                                               # added
[]

[LotsOfDiffusion]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  block                          =                             # The block id where this variable lives
  eigen                          = 0                           # True to make this variable an eigen variable
  family                         = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
  initial_condition              = 0                           # Specifies the initial condition for this variable
  order                          = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
  outputs                        =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
  scaling                        = 1                           # Specifies a scaling factor to apply to this variable
  variables                      = (required)                  # The names of the variables for which CoeffDiffusion kernels should be ...
                                                               # added
[]

[LotsOfEFieldAdvection]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  block                          =                             # The block id where this variable lives
  eigen                          = 0                           # True to make this variable an eigen variable
  family                         = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
  initial_condition              = 0                           # Specifies the initial condition for this variable
  order                          = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
  outputs                        =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
  potential                      = (required)                  # A dummy vector that holds the potential to couple in for advection
  scaling                        = 1                           # Specifies a scaling factor to apply to this variable
  variables                      = (required)                  # The names of the variables for which EFieldAdvection kernels should be ...
                                                               # added
[]

[LotsOfPotentialDrivenArtificialDiff]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  block                          =                             # The block id where this variable lives
  delta                          = 0.5                         # Used for determining the amount of artificial diffusion to add.
  eigen                          = 0                           # True to make this variable an eigen variable
  family                         = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
  initial_condition              = 0                           # Specifies the initial condition for this variable
  order                          = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
  outputs                        =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
  potential                      = (required)                  # A dummy vector that holds the potential to couple in for advection
  scaling                        = 1                           # Specifies a scaling factor to apply to this variable
  variables                      = (required)                  # The names of the variables for which PotentialDrivenArtificialDiff kernels ...
                                                               # should be added
[]

[LotsOfSources]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  block                          =                             # The block id where this variable lives
  eigen                          = 0                           # True to make this variable an eigen variable
  family                         = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
  initial_condition              = 0                           # Specifies the initial condition for this variable
  order                          = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
  outputs                        =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
  scaling                        = 1                           # Specifies a scaling factor to apply to this variable
  variables                      = (required)                  # The names of the variables for which Source kernels should be added
[]

[LotsOfTimeDerivatives]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  block                          =                             # The block id where this variable lives
  eigen                          = 0                           # True to make this variable an eigen variable
  family                         = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
  initial_condition              = 0                           # Specifies the initial condition for this variable
  order                          = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
  outputs                        =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
  scaling                        = 1                           # Specifies a scaling factor to apply to this variable
  variables                      = (required)                  # The names of the variables for which TimeDerivative kernels should be ...
                                                               # added
[]

[LotsOfVariables]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  block                          =                             # The block id where this variable lives
  eigen                          = 0                           # True to make this variable an eigen variable
  family                         = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
  initial_condition              = 0                           # Specifies the initial condition for this variable
  order                          = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
  outputs                        =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
  scaling                        = 1                           # Specifies a scaling factor to apply to this variable
  variables                      = (required)                  # The names of the variables for which CoeffDiffusion kernels should be ...
                                                               # added
[]

[Materials]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./Air]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    em                           =                             # Species concentration needed to calculate the poisson source
    ip                           =                             # Species concentration needed to calculate the poisson source
    output_properties            =                             # List of material properties, from this material, to output (outputs must ...
                                                               # also be defined to an output type)
    outputs                      = none                        # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    potential                    =                             # The potential for calculating the electron velocity
    type                         = Air
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    user_density_mult            = 1                           # Scaling for densities
    user_potential_mult          = 1                           # Scaling for potential
    user_relative_permittivity   = 1                           # Multiplies the permittivity of free space.
  [../]

  [./Argon]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    em                           =                             # Species concentration needed to calculate the poisson source
    mean_electron_energy         =                             # The mean electron energy.
    output_properties            =                             # List of material properties, from this material, to output (outputs must ...
                                                               # also be defined to an output type)
    outputs                      = none                        # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    potential                    =                             # The potential for calculating the electron velocity
    type                         = Argon
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    user_relative_permittivity   = 1                           # Multiplies the permittivity of free space.
  [../]

  [./BlockAverageDiffusionMaterial]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    block_average_userobject     = (required)                  # The name of the UserObject that is going to be computing the average ...
                                                               # value of a variable on each block
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    output_properties            =                             # List of material properties, from this material, to output (outputs must ...
                                                               # also be defined to an output type)
    outputs                      = none                        # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = BlockAverageDiffusionMaterial
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./GenericConstantMaterial]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    output_properties            =                             # List of material properties, from this material, to output (outputs must ...
                                                               # also be defined to an output type)
    outputs                      = none                        # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    prop_names                   =                             # The names of the properties this material will have
    prop_values                  =                             # The values associated with the named properties
    type                         = GenericConstantMaterial
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./GenericFunctionMaterial]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    output_properties            =                             # List of material properties, from this material, to output (outputs must ...
                                                               # also be defined to an output type)
    outputs                      = none                        # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    prop_names                   =                             # The names of the properties this material will have
    prop_values                  =                             # The corresponding names of the functions that are going to provide the ...
                                                               # values for the variables
    type                         = GenericFunctionMaterial
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NoCouplingAir]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    consistent                   = 0                           # Whether to use consistent stabilization vs. inconsistent isotropic diffusion
    delta                        = 0.5                         # Scaling parameter for artificial diffusivity
    ionization_multiplier        = 1                           # This multiplies the ionization coefficient in case you want to modify ...
                                                               # the magnitude of ionization.
    output_properties            =                             # List of material properties, from this material, to output (outputs must ...
                                                               # also be defined to an output type)
    outputs                      = none                        # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    potential                    =                             # The potential for calculating the electron velocity
    relative_permittivity        = 1                           # Multiplies the permittivity of free space.
    type                         = NoCouplingAir
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    user_density_mult            = 1e+19                       # Scaling for densities
    user_diffusivity             = 0.1                         # Diffusivity specified by the user
    user_potential_mult          = 10000                       # Scaling for potential
    velocity_function            =                             # name of velocity function to utilize
    velocity_multiplier          = 1                           # This multiplies the velocity coefficient in case you want to modify the ...
                                                               # magnitude of the velocity.
  [../]

  [./WD]
    atomic_ion_density           =                             # The atomic ion density
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    consistent                   = 0                           # Whether to use consistent stabilization vs. inconsistent isotropic diffusion
    delta                        = 0.5                         # Scaling parameter for artificial diffusivity
    molecular_ion_density        =                             # The molecular ion density
    output_properties            =                             # List of material properties, from this material, to output (outputs must ...
                                                               # also be defined to an output type)
    outputs                      = none                        # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    potential                    =                             # The potential for calculating the electron velocity
    r_velocity                   =                             # The velocity in the radial direction
    type                         = WD
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    user_diffusivity             = 0.1                         # Diffusivity specified by the user
    velocity_function            =                             # name of velocity function to utilize
    z_velocity                   =                             # The velocity in the axial direction
  [../]

  [./Water]
    H                            =                             # hydrogen atoms
    H2                           =                             # hydrogen molecules
    H2O2                         =                             # hydrogen peroxide molecules
    H2Op                         =                             # positive water ions
    H3Op                         =                             # positive hydronium cations
    HO2                          =                             # HO2 molecules
    HO2m                         =                             # HO2 anions
    O                            =                             # oxygen atoms
    O2                           =                             # oxygen molecules
    O2m                          =                             # molecular oxygen anions
    O3                           =                             # ozone molecules
    O3m                          =                             # ozone anions
    OH                           =                             # hydroxyl molecules
    OHm                          =                             # hydroxide ions
    Om                           =                             # atomic oxygen anions
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    em                           =                             # electrons
    output_properties            =                             # List of material properties, from this material, to output (outputs must ...
                                                               # also be defined to an output type)
    outputs                      = none                        # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = Water
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    user_electron_mult           = (required)                  # Scaling for the electrons.
    user_potential_mult          = (required)                  # Scaling for the potential.
    user_relative_permittivity   = 78.5                        # The relative permittivity of the medium.
  [../]
[]

[Mesh]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  displacements                  =                             # The variables corresponding to the x y z displacements of the mesh.  ...
                                                               # If this is provided then the displacements will be taken into account ...
                                                               # during the computation.
  block_id                       =                             # IDs of the block id/name pairs
  block_name                     =                             # Names of the block id/name pairs (must correspond with "block_id"
  boundary_id                    =                             # IDs of the boundary id/name pairs
  boundary_name                  =                             # Names of the boundary id/name pairs (must correspond with "boundary_id"
  construct_side_list_from_node_list = 0                           # If true, construct side lists from the nodesets in the mesh (i.e. if ...
                                                               # every node on a give side is in a nodeset then add that side to a sideset
  ghosted_boundaries             =                             # Boundaries to be ghosted if using Nemesis
  ghosted_boundaries_inflation   =                             # If you are using ghosted boundaries you will want to set this value to ...
                                                               # a vector of amounts to inflate the bounding boxes by.  ie if you are ...
                                                               # running a 3D problem you might set it to '0.2 0.1 0.4'
  patch_size                     = 40                          # The number of nodes to consider in the NearestNode neighborhood.
  second_order                   = 0                           # Converts a first order mesh to a second order mesh.  Note: This is NOT ...
                                                               # needed if you are reading an actual first order mesh.
  skip_partitioning              = 0                           # If true the mesh won't be partitioned. This may cause large load imbalanced ...
                                                               # but is currently required if you have a simulation containing uniform ...
                                                               # refinement, adaptivity and stateful material properties
  type                           = FileMesh                    # A string representing the Moose Object that will be built by this Action
  uniform_refine                 = 0                           # Specify the level of uniform refinement applied to the initial mesh

  [./<type>]

    [./FileMesh]
      centroid_partitioner_direction =                             # Specifies the sort direction if using the centroid partitioner. Available ...
                                                               # options: x, y, z, radial
      dim                        = 3                           # This is only required for certain mesh formats where the dimension of ...
                                                               # the mesh cannot be autodetected.  In particular you must supply this ...
                                                               # for GMSH meshes.  Note: This is completely ignored for ExodusII meshes!
      distribution               = DEFAULT                     # PARALLEL: Always use libMesh::ParallelMesh SERIAL: Always use libMesh::SerialMesh ...
                                                               # DEFAULT: Use libMesh::SerialMesh unless --parallel-mesh is specified ...
                                                               # on the command line
      file                       = (required)                  # The name of the mesh file to read
      nemesis                    = 0                           # If nemesis=true and file=foo.e, actually reads foo.e.N.0, foo.e.N.1, ...
                                                               # ... foo.e.N.N-1, where N = # CPUs, with NemesisIO.
      partitioner                = default                     # Specifies a mesh partitioner to use when splitting the mesh for a parallel ...
                                                               # computation.
      patch_update_strategy      = never                       # How often to update the geometric search 'patch'.  The default is to ...
                                                               # never update it (which is the most efficient but could be a problem with ...
                                                               # lots of relative motion).  'always' will update the patch every timestep ...
                                                               # which might be time consuming.  'auto' will attempt to determine when ...
                                                               # the patch size needs to be updated automatically.
      type                       = FileMesh
    [../]

    [./GeneratedMesh]
      centroid_partitioner_direction =                             # Specifies the sort direction if using the centroid partitioner. Available ...
                                                               # options: x, y, z, radial
      dim                        = (required)                  # The dimension of the mesh to be generated
      distribution               = DEFAULT                     # PARALLEL: Always use libMesh::ParallelMesh SERIAL: Always use libMesh::SerialMesh ...
                                                               # DEFAULT: Use libMesh::SerialMesh unless --parallel-mesh is specified ...
                                                               # on the command line
      elem_type                  =                             # The type of element from libMesh to generate (default: linear element ...
                                                               # for requested dimension)
      nemesis                    = 0                           # If nemesis=true and file=foo.e, actually reads foo.e.N.0, foo.e.N.1, ...
                                                               # ... foo.e.N.N-1, where N = # CPUs, with NemesisIO.
      nx                         = 1                           # Number of elements in the X direction
      ny                         = 1                           # Number of elements in the Y direction
      nz                         = 1                           # Number of elements in the Z direction
      partitioner                = default                     # Specifies a mesh partitioner to use when splitting the mesh for a parallel ...
                                                               # computation.
      patch_update_strategy      = never                       # How often to update the geometric search 'patch'.  The default is to ...
                                                               # never update it (which is the most efficient but could be a problem with ...
                                                               # lots of relative motion).  'always' will update the patch every timestep ...
                                                               # which might be time consuming.  'auto' will attempt to determine when ...
                                                               # the patch size needs to be updated automatically.
      type                       = GeneratedMesh
      xmax                       = 1                           # Upper X Coordinate of the generated mesh
      xmin                       = 0                           # Lower X Coordinate of the generated mesh
      ymax                       = 1                           # Upper Y Coordinate of the generated mesh
      ymin                       = 0                           # Lower Y Coordinate of the generated mesh
      zmax                       = 1                           # Upper Z Coordinate of the generated mesh
      zmin                       = 0                           # Lower Z Coordinate of the generated mesh
    [../]

    [./TiledMesh]
      back_boundary              = back_boundary               # name of the back (z) boundary
      bottom_boundary            = bottom_boundary             # name of the bottom (y) boundary
      centroid_partitioner_direction =                             # Specifies the sort direction if using the centroid partitioner. Available ...
                                                               # options: x, y, z, radial
      dim                        = 3                           # This is only required for certain mesh formats where the dimension of ...
                                                               # the mesh cannot be autodetected.  In particular you must supply this ...
                                                               # for GMSH meshes.  Note: This is completely ignored for ExodusII meshes!
      distribution               = DEFAULT                     # PARALLEL: Always use libMesh::ParallelMesh SERIAL: Always use libMesh::SerialMesh ...
                                                               # DEFAULT: Use libMesh::SerialMesh unless --parallel-mesh is specified ...
                                                               # on the command line
      file                       = (required)                  # The name of the mesh file to read
      front_boundary             = front_boundary              # name of the front (z) boundary
      left_boundary              = left_boundary               # name of the left (x) boundary
      nemesis                    = 0                           # If nemesis=true and file=foo.e, actually reads foo.e.N.0, foo.e.N.1, ...
                                                               # ... foo.e.N.N-1, where N = # CPUs, with NemesisIO.
      partitioner                = default                     # Specifies a mesh partitioner to use when splitting the mesh for a parallel ...
                                                               # computation.
      patch_update_strategy      = never                       # How often to update the geometric search 'patch'.  The default is to ...
                                                               # never update it (which is the most efficient but could be a problem with ...
                                                               # lots of relative motion).  'always' will update the patch every timestep ...
                                                               # which might be time consuming.  'auto' will attempt to determine when ...
                                                               # the patch size needs to be updated automatically.
      right_boundary             = right_boundary              # name of the right (x) boundary
      top_boundary               = top_boundary                # name of the top (y) boundary
      type                       = TiledMesh
      x_tiles                    = 1                           # Number of tiles to stitch together (left to right) in the x-direction
      x_width                    = 0                           # The tile width in the x direction
      y_tiles                    = 1                           # Number of tiles to stitch together (top to bottom) in the y-direction
      y_width                    = 0                           # The tile width in the y direction
      z_tiles                    = 1                           # Number of tiles to stitch together (front to back) in the z-direction
      z_width                    = 0                           # The tile width in the z direction
    [../]
  [../]

  [./MortarInterfaces]

    [./*]
      active                     = __all__                     # If specified only the blocks named will be visited and made active
      master                     = (required)                  # Master side ID
      slave                      = (required)                  # Slave side ID
      subdomain                  = (required)                  # Subdomain name that is the mortar interface
    [../]
  [../]
[]

[MeshModifiers]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./AddAllSideSetsByNormals]
    fixed_normal                 = 0                           # This Boolean determines whether we fix our normal or allow it to vary ...
                                                               # to "paint" around curves
    type                         = AddAllSideSetsByNormals
    variance                     = 0.1                         # The variance [0.0 - 1.0] allowed when comparing normals
  [../]

  [./AddExtraNodeset]
    coord                        =                             # The nodes with coordinates you want to be in the nodeset (Either this ...
                                                               # parameter or "nodes" must be supplied).
    new_boundary                 = (required)                  # The name of the boundary to create
    nodes                        =                             # The nodes you want to be in the nodeset (Either this parameter or "coord" ...
                                                               # must be supplied).
    tolerance                    = 1e-06                       # The tolerance in which two nodes are considered identical
    type                         = AddExtraNodeset
  [../]

  [./MeshExtruder]
    bottom_sideset               =                             # The boundary that will be applied to the bottom of the extruded mesh
    extrusion_vector             = (required)                  # The direction and length of the extrusion
    num_layers                   = (required)                  # The number of layers in the extruded mesh
    top_sideset                  =                             # The boundary that will be to the top of the extruded mesh
    type                         = MeshExtruder
  [../]

  [./OrientedSubdomainBoundingBox]
    block_id                     = (required)                  # Subdomain id to set for inside/outside the bounding box
    center                       = (required)                  # The center (many people spell this 'center') of the box.
    height                       = (required)                  # The height of the box
    length                       = (required)                  # The length of the box
    length_direction             = (required)                  # The direction along which the length is oriented (must be perpendicular ...
                                                               # to width_direction).
    location                     = INSIDE                      # Control of where the subdomain id is to be set
    type                         = OrientedSubdomainBoundingBox
    width                        = (required)                  # The width of the box
    width_direction              = (required)                  # The direction along which the width is oriented.
  [../]

  [./RenameBlock]
    new_block_id                 =                             # Elements with the old block number (or name) will be given this block ...
                                                               # number.  You must supply either new_block_id or new_block_name.  You ...
                                                               # may supply a vector of new_block_id, in which case the old_block information ...
                                                               # must also be a vector.
    new_block_name               =                             # Elements with the old block number (or name) will be given this block ...
                                                               # name.  You must supply either new_block_id or new_block_name.  You may ...
                                                               # supply a vector of new_block_id, in which case the old_block information ...
                                                               # must also be a vector.
    old_block_id                 =                             # Elements with this block number will be given the new_block_number or ...
                                                               # new_block_name.  You must supply either old_block_id or old_block_name. ...
                                                               # You may supply a vector of old_block_id, in which case the new_block ...
                                                               # information must also be a vector.
    old_block_name               =                             # Elements with this block name will be given the new_block_number or new_block_name. ...
                                                               # You must supply either old_block_id or old_block_name.  You may supply ...
                                                               # a vector of old_block_name, in which case the new_block information must ...
                                                               # also be a vector.
    type                         = RenameBlock
  [../]

  [./SideSetsAroundSubdomain]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    fixed_normal                 = 0                           # This Boolean determines whether we fix our normal or allow it to vary ...
                                                               # to "paint" around curves
    new_boundary                 = (required)                  # The list of boundary IDs to create on the supplied subdomain
    normal                       =                             # If supplied, only faces with normal equal to this, up to normal_tol, ...
                                                               # will be added to the sidesets specified
    normal_tol                   = 0.1                         # If normal is supplied then faces are only added if face_normal.normal_hat ...
                                                               # >= 1 - normal_tol, where normal_hat = normal/|normal|
    type                         = SideSetsAroundSubdomain
    variance                     = 0.1                         # The variance [0.0 - 1.0] allowed when comparing normals
  [../]

  [./SideSetsBetweenSubdomains]
    master_block                 = (required)                  # The first block for which to draw a sideset between
    new_boundary                 = (required)                  # The name of the boundary to create
    paired_block                 = (required)                  # The second block for which to draw a sideset between
    type                         = SideSetsBetweenSubdomains
  [../]

  [./SideSetsFromNormals]
    fixed_normal                 = 0                           # This Boolean determines whether we fix our normal or allow it to vary ...
                                                               # to "paint" around curves
    new_boundary                 = (required)                  # The name of the boundary to create
    normals                      = (required)                  # A list of normals for which to start painting sidesets
    type                         = SideSetsFromNormals
    variance                     = 0.1                         # The variance [0.0 - 1.0] allowed when comparing normals
  [../]

  [./SideSetsFromPoints]
    fixed_normal                 = 0                           # This Boolean determines whether we fix our normal or allow it to vary ...
                                                               # to "paint" around curves
    new_boundary                 = (required)                  # The name of the boundary to create
    points                       = (required)                  # A list of points from which to start painting sidesets
    type                         = SideSetsFromPoints
    variance                     = 0.1                         # The variance [0.0 - 1.0] allowed when comparing normals
  [../]

  [./SubdomainBoundingBox]
    block_id                     = (required)                  # Subdomain id to set for inside/outside the bounding box
    block_name                   =                             # Subdomain name to set for inside/outside the bounding box (optional)
    bottom_left                  = (required)                  # The bottom left point (in x,y,z with spaces in-between).
    location                     = INSIDE                      # Control of where the subdomain id is to be set
    top_right                    = (required)                  # The bottom left point (in x,y,z with spaces in-between).
    type                         = SubdomainBoundingBox
  [../]

  [./Transform]
    transform                    = (required)                  # The type of transformation to perform (TRANSLATE, ROTATE, SCALE)
    type                         = Transform
    vector_value                 = (required)                  # The value to use for the transformation. When using TRANSLATE or SCALE, ...
                                                               # the xyz coordinates are applied in each direction respectively. When ...
                                                               # using ROTATE, the values are interpreted as the Euler angles phi, theta ...
                                                               # and psi given in degrees.
  [../]
[]

[MultiApps]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./AutoPositionsMultiApp]
    app_type                     = (required)                  # The type of application to build (applications not registered can be ...
                                                               # loaded with dynamic libraries.
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    bounding_box_inflation       = 0.01                        # Relative amount to 'inflate' the bounding box of this MultiApp.
    catch_up                     = 0                           # If true this will allow failed solves to attempt to 'catch up' using ...
                                                               # smaller timesteps.
    detect_steady_state          = 0                           # If true then while sub_cycling a steady state check will be done.  In ...
                                                               # this mode output will only be done once the MultiApp reaches the target ...
                                                               # time or steady state is reached
    execute_on                   = TIMESTEP_BEGIN              # Set to (linear|nonlinear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    input_files                  = (required)                  # The input file for each App.  If this parameter only contains one input ...
                                                               # file it will be used for all of the Apps.
    interpolate_transfers        = 0                           # Only valid when sub_cycling.  This allows transferred values to be interpolated ...
                                                               # over the time frame the MultiApp is executing over when sub_cycling
    library_path                 =                             # Path to search for dynamic libraries (please avoid committing absolute ...
                                                               # paths in addition to MOOSE_LIBRARY_PATH)
    max_catch_up_steps           = 2                           # Maximum number of steps to allow an app to take when trying to catch ...
                                                               # back up after a failed solve.
    max_failures                 = 0                           # Maximum number of solve failures tolerated while sub_cycling.
    max_procs_per_app            = 4294967295                  # Maximum number of processors to give to each App in this MultiApp.  Useful ...
                                                               # for restricting small solves to just a few procs so they don't get spread ...
                                                               # out
    move_apps                    =                             # Apps, designated by their 'numbers' starting with 0 corresponding to ...
                                                               # the order of the App positions, to be moved at move_time to move_positions
    move_positions               =                             # The positions corresponding to each move_app.
    move_time                    = 1.79769e+308                # The time at which Apps designated by move_apps are moved to move_positions.
    output_in_position           = 0                           # If true this will cause the output from the MultiApp to be 'moved' by ...
                                                               # its position vector
    output_sub_cycles            = 0                           # If true when sub_cycling every sub-cycle will be output.
    print_sub_cycles             = 1                           # Toggle the display of sub-cycles on the screen.
    reset_apps                   =                             # The Apps that will be reset when 'reset_time' is hit.  These are the ...
                                                               # App 'numbers' starting with 0 corresponding to the order of the App positions. ...
                                                               # Resetting an App means that it is destroyed and recreated, possibly modeling ...
                                                               # the insertion of 'new' material for that app.
    reset_time                   = 1.79769e+308                # The time at which to reset Apps given by the 'reset_apps' parameter. ...
                                                               # Resetting an App means that it is destroyed and recreated, possibly modeling ...
                                                               # the insertion of 'new' material for that app.
    steady_state_tol             = 1e-08                       # The relative difference between the new solution and the old solution ...
                                                               # that will be considered to be at steady state
    sub_cycling                  = 0                           # Set to true to allow this MultiApp to take smaller timesteps than the ...
                                                               # rest of the simulation.  More than one timestep will be performed for ...
                                                               # each 'master' timestep
    tolerate_failure             = 0                           # If true this MultiApp won't participate in dt decisions and will always ...
                                                               # be fast-forwarded to the current time.
    type                         = AutoPositionsMultiApp
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./FullSolveMultiApp]
    app_type                     = (required)                  # The type of application to build (applications not registered can be ...
                                                               # loaded with dynamic libraries.
    bounding_box_inflation       = 0.01                        # Relative amount to 'inflate' the bounding box of this MultiApp.
    execute_on                   = TIMESTEP_BEGIN              # Set to (linear|nonlinear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    input_files                  = (required)                  # The input file for each App.  If this parameter only contains one input ...
                                                               # file it will be used for all of the Apps.
    library_path                 =                             # Path to search for dynamic libraries (please avoid committing absolute ...
                                                               # paths in addition to MOOSE_LIBRARY_PATH)
    max_procs_per_app            = 4294967295                  # Maximum number of processors to give to each App in this MultiApp.  Useful ...
                                                               # for restricting small solves to just a few procs so they don't get spread ...
                                                               # out
    move_apps                    =                             # Apps, designated by their 'numbers' starting with 0 corresponding to ...
                                                               # the order of the App positions, to be moved at move_time to move_positions
    move_positions               =                             # The positions corresponding to each move_app.
    move_time                    = 1.79769e+308                # The time at which Apps designated by move_apps are moved to move_positions.
    output_in_position           = 0                           # If true this will cause the output from the MultiApp to be 'moved' by ...
                                                               # its position vector
    positions                    =                             # The positions of the App locations.  Each set of 3 values will represent ...
                                                               # a Point.  Either this must be supplied or 'positions_file'
    positions_file               =                             # A filename that should be looked in for positions. Each set of 3 values ...
                                                               # in that file will represent a Point.  Either this must be supplied or ...
                                                               # 'positions'
    reset_apps                   =                             # The Apps that will be reset when 'reset_time' is hit.  These are the ...
                                                               # App 'numbers' starting with 0 corresponding to the order of the App positions. ...
                                                               # Resetting an App means that it is destroyed and recreated, possibly modeling ...
                                                               # the insertion of 'new' material for that app.
    reset_time                   = 1.79769e+308                # The time at which to reset Apps given by the 'reset_apps' parameter. ...
                                                               # Resetting an App means that it is destroyed and recreated, possibly modeling ...
                                                               # the insertion of 'new' material for that app.
    type                         = FullSolveMultiApp
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./TransientMultiApp]
    app_type                     = (required)                  # The type of application to build (applications not registered can be ...
                                                               # loaded with dynamic libraries.
    bounding_box_inflation       = 0.01                        # Relative amount to 'inflate' the bounding box of this MultiApp.
    catch_up                     = 0                           # If true this will allow failed solves to attempt to 'catch up' using ...
                                                               # smaller timesteps.
    detect_steady_state          = 0                           # If true then while sub_cycling a steady state check will be done.  In ...
                                                               # this mode output will only be done once the MultiApp reaches the target ...
                                                               # time or steady state is reached
    execute_on                   = TIMESTEP_BEGIN              # Set to (linear|nonlinear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    input_files                  = (required)                  # The input file for each App.  If this parameter only contains one input ...
                                                               # file it will be used for all of the Apps.
    interpolate_transfers        = 0                           # Only valid when sub_cycling.  This allows transferred values to be interpolated ...
                                                               # over the time frame the MultiApp is executing over when sub_cycling
    library_path                 =                             # Path to search for dynamic libraries (please avoid committing absolute ...
                                                               # paths in addition to MOOSE_LIBRARY_PATH)
    max_catch_up_steps           = 2                           # Maximum number of steps to allow an app to take when trying to catch ...
                                                               # back up after a failed solve.
    max_failures                 = 0                           # Maximum number of solve failures tolerated while sub_cycling.
    max_procs_per_app            = 4294967295                  # Maximum number of processors to give to each App in this MultiApp.  Useful ...
                                                               # for restricting small solves to just a few procs so they don't get spread ...
                                                               # out
    move_apps                    =                             # Apps, designated by their 'numbers' starting with 0 corresponding to ...
                                                               # the order of the App positions, to be moved at move_time to move_positions
    move_positions               =                             # The positions corresponding to each move_app.
    move_time                    = 1.79769e+308                # The time at which Apps designated by move_apps are moved to move_positions.
    output_in_position           = 0                           # If true this will cause the output from the MultiApp to be 'moved' by ...
                                                               # its position vector
    output_sub_cycles            = 0                           # If true when sub_cycling every sub-cycle will be output.
    positions                    =                             # The positions of the App locations.  Each set of 3 values will represent ...
                                                               # a Point.  Either this must be supplied or 'positions_file'
    positions_file               =                             # A filename that should be looked in for positions. Each set of 3 values ...
                                                               # in that file will represent a Point.  Either this must be supplied or ...
                                                               # 'positions'
    print_sub_cycles             = 1                           # Toggle the display of sub-cycles on the screen.
    reset_apps                   =                             # The Apps that will be reset when 'reset_time' is hit.  These are the ...
                                                               # App 'numbers' starting with 0 corresponding to the order of the App positions. ...
                                                               # Resetting an App means that it is destroyed and recreated, possibly modeling ...
                                                               # the insertion of 'new' material for that app.
    reset_time                   = 1.79769e+308                # The time at which to reset Apps given by the 'reset_apps' parameter. ...
                                                               # Resetting an App means that it is destroyed and recreated, possibly modeling ...
                                                               # the insertion of 'new' material for that app.
    steady_state_tol             = 1e-08                       # The relative difference between the new solution and the old solution ...
                                                               # that will be considered to be at steady state
    sub_cycling                  = 0                           # Set to true to allow this MultiApp to take smaller timesteps than the ...
                                                               # rest of the simulation.  More than one timestep will be performed for ...
                                                               # each 'master' timestep
    tolerate_failure             = 0                           # If true this MultiApp won't participate in dt decisions and will always ...
                                                               # be fast-forwarded to the current time.
    type                         = TransientMultiApp
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]
[]

[NodalNormals]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  boundary                       = ANY_BOUNDARY_ID             # The boundary ID or name where the normals will be computed
  corner_boundary                =                             # boundary ID or name with nodes at 'corners'
  order                          = FIRST                       # Specifies the order of variables that hold the nodal normals. Needs to ...
                                                               # match the order of the mesh
[]

[Outputs]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  checkpoint                     = 0                           # Create checkpoint files using the default options.
  color                          = 1                           # Set to false to turn off all coloring in all outputs
  console                        = 1                           # Output the results using the default settings for Console output
  csv                            = 0                           # Output the scalar variable and postprocessors to a *.csv file using the ...
                                                               # default CSV output.
  dofmap                         = 0                           # Create the dof map .json output file
  exodus                         = 0                           # Output the results using the default settings for Exodus output
  file_base                      =                             # Common file base name to be utilized with all output objects
  gmv                            = 0                           # Output the results using the default settings for GMV output
  gnuplot                        = 0                           # Output the scalar and postprocessor results using the default settings ...
                                                               # for GNUPlot output
  hide                           =                             # A list of the variables and postprocessors that should NOT be output ...
                                                               # to the Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
  interval                       = 1                           # The interval at which timesteps are output to the solution file
  nemesis                        = 0                           # Output the results using the default settings for Nemesis output
  output_final                   = 0                           # Force the final time step to be output, regardless of output interval
  output_if_base_contains        =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
  output_initial                 = 0                           # Request that the initial condition is output to the solution file
  output_intermediate            = 1                           # Request that all intermediate steps (not initial or final) are output
  output_on                      = TIMESTEP_END                # Set to (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment (default: timestep_end)
  output_timestep_end            = 1                           # Request that data be output at the end of the timestep
  print_linear_residuals         = 0                           # Enable printing of linear residuals to the screen (Console)
  print_mesh_changed_info        = 0                           # When true, each time the mesh is changed the mesh information is printed
  print_perf_log                 = 0                           # Enable printing of the performance log to the screen (Console)
  show                           =                             # A list of the variables and postprocessors that should be output to the ...
                                                               # Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
  solution_history               = 0                           # Print a solution history file (.slh) using the default settings
  sync_times                     =                             # Times at which the output and solution is forced to occur
  tecplot                        = 0                           # Output the results using the default settings for Tecplot output
  vtk                            = 0                           # Output the results using the default settings for VTKOutput output
  xda                            = 0                           # Output the results using the default settings for XDA/XDR output (ascii)
  xdr                            = 0                           # Output the results using the default settings for XDA/XDR output (binary)

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./CSV]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    align                        = 0                           # Align the outputted csv data by padding the numbers with trailing whitespace
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_restart               = 0                           # Append existing file on restart
    delimiter                    =                             # Assign the delimiter (default is ','
    end_time                     =                             # Time at which this output object stop operating
    file_base                    =                             # The desired solution output name without an extension
    hide                         =                             # A list of the variables and postprocessors that should NOT be output ...
                                                               # to the Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_elemental_variables   = 1                           # Enable/disable the output of elemental variables
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_input                 = 1                           # Enable/disable the output of input file information
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nodal_variables       = 1                           # Enable/disable the output of nodal variables
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_postprocessors        = 1                           # Enable/disable the output of postprocessors
    output_postprocessors_on     =                             # Control of when postprocessors are output
    output_scalar_variables      = 1                           # Enable/disable the output of aux scalar variables
    output_scalars_on            =                             # Control the output of scalar variables
    output_system_information    = 1                           # Enable/disable the output of the simulation information
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    output_vector_postprocessors = 1                           # Enable/disable the output of vector postprocessors
    output_vector_postprocessors_on =                             # Enable/disable the output of VectorPostprocessors
    precision                    = 14                          # Set the output precision
    show                         =                             # A list of the variables and postprocessors that should be output to the ...
                                                               # Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = CSV
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./Checkpoint]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    binary                       = 1                           # Toggle the output of binary files
    end_time                     =                             # Time at which this output object stop operating
    file_base                    =                             # The desired solution output name without an extension
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    num_files                    = 2                           # Number of the restart files to save
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    start_time                   =                             # Time at which this output object begins to operate
    suffix                       = cp                          # This will be appended to the file_base to create the directory name for ...
                                                               # checkpoint files.
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = Checkpoint
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./Console]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    all_variable_norms           = 0                           # If true, all variable norms will be printed after each solve
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_restart               = 0                           # Append existing file on restart
    end_time                     =                             # Time at which this output object stop operating
    file_base                    =                             # The desired solution output name without an extension
    fit_mode                     = ENVIRONMENT                 # Specifies the wrapping mode for post-processor tables that are printed ...
                                                               # to the screen (ENVIRONMENT: Read "MOOSE_PPS_WIDTH" for desired width, ...
                                                               # AUTO: Attempt to determine width automatically (serial only), <n>: Desired ...
                                                               # width
    hide                         =                             # A list of the variables and postprocessors that should NOT be output ...
                                                               # to the Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    max_rows                     = 15                          # The maximum number of postprocessor/scalar values displayed on screen ...
                                                               # during a timestep (set to 0 for unlimited)
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    outlier_multiplier           = '0.8 2'                     # Multiplier utilized to determine if a residual norm is an outlier. If ...
                                                               # the variable residual is less than multiplier[0] times the total residual ...
                                                               # it is colored red. If the variable residual is less than multiplier[1] ...
                                                               # times the average residual it is colored yellow.
    outlier_variable_norms       = 1                           # If true, outlier variable norms will be printed after each solve
    output_elemental_variables   = 1                           # Enable/disable the output of elemental variables
    output_failed                = 0                           # When true all time attempted time steps are output
    output_file                  = 0                           # Output to the file
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_input                 = 1                           # Enable/disable the output of input file information
    output_input_on              =                             # Enable/disable the output of the input file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nodal_variables       = 1                           # Enable/disable the output of nodal variables
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = 'FAILED NONLINEAR TIMESTEP_BEGIN TIMESTEP_END'# Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_postprocessors        = 1                           # Enable/disable the output of postprocessors
    output_postprocessors_on     = TIMESTEP_END                # Control of when postprocessors are output
    output_scalar_variables      = 1                           # Enable/disable the output of aux scalar variables
    output_scalars_on            = TIMESTEP_END                # Control the output of scalar variables
    output_screen                = 1                           # Output to the screen
    output_system_information    = 1                           # Enable/disable the output of the simulation information
    output_system_information_on = INITIAL                     # Control when the output of the simulation information occurs
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    output_vector_postprocessors = 1                           # Enable/disable the output of vector postprocessors
    output_vector_postprocessors_on = TIMESTEP_END                # Enable/disable the output of VectorPostprocessors
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    perf_header                  =                             # Print the libMesh performance log header (requires that 'perf_log = true')
    perf_log                     = 0                           # If true, all performance logs will be printed. The individual log settings ...
                                                               # will override this option.
    print_mesh_changed_info      = 0                           # When true, each time the mesh is changed the mesh information is printed
    scientific_time              = 0                           # Control the printing of time and dt in scientific notation
    setup_log                    =                             # Toggles the printing of the 'Setup Performance' log
    setup_log_early              = 0                           # Specifies whether or not the Setup Performance log should be printed ...
                                                               # before the first time step.  It will still be printed at the end if perf_log ...
                                                               # is also enabled and likewise disabled if perf_log is false
    show                         =                             # A list of the variables and postprocessors that should be output to the ...
                                                               # Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    show_multiapp_name           = 0                           # Indent multiapp output using the multiapp name
    solve_log                    =                             # Toggles the printing of the 'Moose Test Performance' log
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    system_info                  = 'AUX EXECUTION FRAMEWORK MESH NONLINEAR'# List of information types to display ('framework', 'mesh', 'aux', 'nonlinear', ...
                                                               # 'execution', 'output')
    time_precision               =                             # The number of significant digits that are printed on time related outputs
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = Console
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
    verbose                      = 0                           # Print detailed diagnostics on timestep calculation
  [../]

  [./DOFMap]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    end_time                     =                             # Time at which this output object stop operating
    file_base                    =                             # The desired solution output name without an extension
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_failed                = 0                           # When true all time attempted time steps are output
    output_file                  = 1                           # Output to the file
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = INITIAL                     # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_screen                = 0                           # Output to the screen
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    system_name                  = nl0                         # System to output
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = DOFMap
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./Exodus]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_oversample            = 0                           # Append '_oversample' to the output file base
    elemental_as_nodal           = 0                           # Output elemental nonlinear variables as nodal
    end_time                     =                             # Time at which this output object stop operating
    ensight_time                 = 0                           # Control the use of timesteps that are compatible for EnSight, this is ...
                                                               # only needed if the timesteps can not be stored with single precision
    file                         =                             # The name of the mesh file to read, for oversampling
    file_base                    =                             # The desired solution output name without an extension
    hide                         =                             # A list of the variables and postprocessors that should NOT be output ...
                                                               # to the Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_elemental_on          =                             # Control the output of elemental variables
    output_elemental_variables   = 1                           # Enable/disable the output of elemental variables
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_input                 = 1                           # Enable/disable the output of input file information
    output_input_on              = INITIAL                     # Enable/disable the output of the input file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_material_properties   = 0                           # Flag indicating if material properties should be output
    output_nodal_on              =                             # Control the output of nodal variables
    output_nodal_variables       = 1                           # Enable/disable the output of nodal variables
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_postprocessors        = 1                           # Enable/disable the output of postprocessors
    output_postprocessors_on     =                             # Control of when postprocessors are output
    output_scalar_variables      = 1                           # Enable/disable the output of aux scalar variables
    output_scalars_on            =                             # Control the output of scalar variables
    output_system_information    = 1                           # Enable/disable the output of the simulation information
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    output_vector_postprocessors = 1                           # Enable/disable the output of vector postprocessors
    oversample                   = 0                           # Set to true to enable oversampling
    padding                      = 3                           # The number of for extension suffix (e.g., out.e-s002)
    position                     =                             # Set a positional offset, this vector will get added to the nodal coordinates ...
                                                               # to move the domain.
    refinements                  = 0                           # Number of uniform refinements for oversampling (refinement levels beyond ...
                                                               # any uniform refinements)
    scalar_as_nodal              = 0                           # Output scalar variables as nodal
    sequence                     =                             # Enable/disable sequential file output (enabled by default when 'use_displace ...
                                                               # = true', otherwise defaults to false
    show                         =                             # A list of the variables and postprocessors that should be output to the ...
                                                               # Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    show_material_properties     =                             # List of materialproperties that should be written to the output
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = Exodus
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./GMV]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_oversample            = 0                           # Append '_oversample' to the output file base
    binary                       = 1                           # Output the file in binary format
    end_time                     =                             # Time at which this output object stop operating
    file                         =                             # The name of the mesh file to read, for oversampling
    file_base                    =                             # The desired solution output name without an extension
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    oversample                   = 0                           # Set to true to enable oversampling
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    position                     =                             # Set a positional offset, this vector will get added to the nodal coordinates ...
                                                               # to move the domain.
    refinements                  = 0                           # Number of uniform refinements for oversampling (refinement levels beyond ...
                                                               # any uniform refinements)
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = GMV
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./Gnuplot]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_restart               = 0                           # Append existing file on restart
    end_time                     =                             # Time at which this output object stop operating
    extension                    = png                         # GNU plot file extension
    file_base                    =                             # The desired solution output name without an extension
    hide                         =                             # A list of the variables and postprocessors that should NOT be output ...
                                                               # to the Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_elemental_variables   = 1                           # Enable/disable the output of elemental variables
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_input                 = 1                           # Enable/disable the output of input file information
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nodal_variables       = 1                           # Enable/disable the output of nodal variables
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_postprocessors        = 1                           # Enable/disable the output of postprocessors
    output_postprocessors_on     =                             # Control of when postprocessors are output
    output_scalar_variables      = 1                           # Enable/disable the output of aux scalar variables
    output_scalars_on            =                             # Control the output of scalar variables
    output_system_information    = 1                           # Enable/disable the output of the simulation information
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    output_vector_postprocessors = 1                           # Enable/disable the output of vector postprocessors
    output_vector_postprocessors_on =                             # Enable/disable the output of VectorPostprocessors
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    show                         =                             # A list of the variables and postprocessors that should be output to the ...
                                                               # Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = Gnuplot
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./MaterialPropertyDebugOutput]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    end_time                     =                             # Time at which this output object stop operating
    interval                     = 1                           # The interval at which time steps are output to the solution file
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = MaterialPropertyDebugOutput
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./Nemesis]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_oversample            = 0                           # Append '_oversample' to the output file base
    end_time                     =                             # Time at which this output object stop operating
    file                         =                             # The name of the mesh file to read, for oversampling
    file_base                    =                             # The desired solution output name without an extension
    hide                         =                             # A list of the variables and postprocessors that should NOT be output ...
                                                               # to the Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_elemental_variables   = 1                           # Enable/disable the output of elemental variables
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_input                 = 1                           # Enable/disable the output of input file information
    output_input_on              =                             # Enable/disable the output of the input file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nodal_variables       = 1                           # Enable/disable the output of nodal variables
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_postprocessors        = 1                           # Enable/disable the output of postprocessors
    output_postprocessors_on     =                             # Control of when postprocessors are output
    output_scalar_variables      = 1                           # Enable/disable the output of aux scalar variables
    output_scalars_on            =                             # Control the output of scalar variables
    output_system_information    = 1                           # Enable/disable the output of the simulation information
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    output_vector_postprocessors = 1                           # Enable/disable the output of vector postprocessors
    oversample                   = 0                           # Set to true to enable oversampling
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    position                     =                             # Set a positional offset, this vector will get added to the nodal coordinates ...
                                                               # to move the domain.
    refinements                  = 0                           # Number of uniform refinements for oversampling (refinement levels beyond ...
                                                               # any uniform refinements)
    show                         =                             # A list of the variables and postprocessors that should be output to the ...
                                                               # Exodus file (may include Variables, ScalarVariables, and Postprocessor ...
                                                               # names).
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = Nemesis
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./SolutionHistory]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    end_time                     =                             # Time at which this output object stop operating
    file_base                    =                             # The desired solution output name without an extension
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = SolutionHistory
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./Tecplot]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_oversample            = 0                           # Append '_oversample' to the output file base
    ascii_append                 = 0                           # If true, append to an existing ASCII file rather than creating a new ...
                                                               # file each time
    binary                       = 0                           # Set Tecplot files to output in binary format
    end_time                     =                             # Time at which this output object stop operating
    file                         =                             # The name of the mesh file to read, for oversampling
    file_base                    =                             # The desired solution output name without an extension
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    oversample                   = 0                           # Set to true to enable oversampling
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    position                     =                             # Set a positional offset, this vector will get added to the nodal coordinates ...
                                                               # to move the domain.
    refinements                  = 0                           # Number of uniform refinements for oversampling (refinement levels beyond ...
                                                               # any uniform refinements)
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = Tecplot
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./TopResidualDebugOutput]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    end_time                     =                             # Time at which this output object stop operating
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    num_residuals                = 0                           # The number of top residuals to print out (0 = no output)
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = 'LINEAR NONLINEAR TIMESTEP_END'# Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = TopResidualDebugOutput
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./VariableResidualNormsDebugOutput]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    end_time                     =                             # Time at which this output object stop operating
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = NONLINEAR                   # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = VariableResidualNormsDebugOutput
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./XDA]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_oversample            = 0                           # Append '_oversample' to the output file base
    end_time                     =                             # Time at which this output object stop operating
    file                         =                             # The name of the mesh file to read, for oversampling
    file_base                    =                             # The desired solution output name without an extension
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    oversample                   = 0                           # Set to true to enable oversampling
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    position                     =                             # Set a positional offset, this vector will get added to the nodal coordinates ...
                                                               # to move the domain.
    refinements                  = 0                           # Number of uniform refinements for oversampling (refinement levels beyond ...
                                                               # any uniform refinements)
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = XDA
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]

  [./XDR]
    additional_output_on         =                             # This list of output flags is added to the existing flags (initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    append_displaced             = 0                           # Append '_displaced' to the output file base
    append_oversample            = 0                           # Append '_oversample' to the output file base
    end_time                     =                             # Time at which this output object stop operating
    file                         =                             # The name of the mesh file to read, for oversampling
    file_base                    =                             # The desired solution output name without an extension
    interval                     = 1                           # The interval at which time steps are output to the solution file
    linear_residual_dt_divisor   = 1000                        # Number of divisions applied to time step when outputting linear residuals
    linear_residual_end_time     =                             # Specifies an end time to begin output on each linear residual evaluation
    linear_residual_start_time   =                             # Specifies a start time to begin output on each linear residual evaluation
    linear_residuals             = 0                           # Specifies whether output occurs on each linear residual evaluation
    nonlinear_residual_dt_divisor = 1000                        # Number of divisions applied to time step when outputting non-linear residuals
    nonlinear_residual_end_time  =                             # Specifies an end time to begin output on each nonlinear residual evaluation
    nonlinear_residual_start_time =                             # Specifies a start time to begin output on each nonlinear residual evaluation
    nonlinear_residuals          = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_failed                = 0                           # When true all time attempted time steps are output
    output_final                 = 0                           # Force the final time step to be output, regardless of output interval
    output_if_base_contains      =                             # If this is supplied then output will only be done in the case that the ...
                                                               # output base contains one of these strings.  This is helpful in outputting ...
                                                               # only a subset of outputs when using MultiApps.
    output_initial               = 0                           # Request that the initial condition is output to the solution file
    output_intermediate          = 1                           # Request that all intermediate steps (not initial or final) are output
    output_linear                = 0                           # Specifies whether output occurs on each linear residual evaluation
    output_nonlinear             = 0                           # Specifies whether output occurs on each nonlinear residual evaluation
    output_on                    = TIMESTEP_END                # Set to (none|initial|linear|nonlinear|timestep_end|timestep_begin|final|failed|custom) ...
                                                               # to execute only at that moment
    output_timestep_end          = 1                           # Request that data be output at the end of the timestep
    oversample                   = 0                           # Set to true to enable oversampling
    padding                      = 4                           # The number of for extension suffix (e.g., out.e-s002)
    position                     =                             # Set a positional offset, this vector will get added to the nodal coordinates ...
                                                               # to move the domain.
    refinements                  = 0                           # Number of uniform refinements for oversampling (refinement levels beyond ...
                                                               # any uniform refinements)
    start_time                   =                             # Time at which this output object begins to operate
    sync_only                    = 0                           # Only export results at sync times
    sync_times                   =                             # Times at which the output and solution is forced to occur
    time_tolerance               = 1e-14                       # Time tolerance utilized checking start and end times
    type                         = XDR
    use_displaced                = 0                           # Enable/disable the use of the displaced mesh for outputting
  [../]
[]

[Postprocessors]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./AreaPostprocessor]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = AreaPostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./AverageElementSize]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = AverageElementSize
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./AverageNodalVariableValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = AverageNodalVariableValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./BlockAverageValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    built_by_action              = add_user_object
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = BlockAverageValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./DifferencePostprocessor]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = DifferencePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value1                       = (required)                  # First value
    value2                       = (required)                  # Second value
  [../]

  [./ElementAverageTimeDerivative]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementAverageTimeDerivative
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementAverageValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementAverageValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementExtremeValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementExtremeValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value_type                   = max                         # Type of extreme value to return. 'max' returns the maximum value. 'min' ...
                                                               # returns the minimum value.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./ElementH1Error]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    p                            = 2                           # The exponent used in the norm.
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementH1Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementH1SemiError]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementH1SemiError
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementIntegralMaterialProperty]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    mat_prop                     = (required)                  # The name of the material property
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementIntegralMaterialProperty
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./ElementIntegralVariablePostprocessor]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementIntegralVariablePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementL2Error]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementL2Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementL2Norm]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementL2Norm
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementVectorL2Error]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function_x                   = (required)                  # The analytic solution to compare against
    function_y                   = 0                           # The analytic solution to compare against
    function_z                   = 0                           # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementVectorL2Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    var_x                        = (required)                  # The FE solution in x direction
    var_y                        = 0                           # The FE solution in y direction
    var_z                        = 0                           # The FE solution in z direction
  [../]

  [./ElementW1pError]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    p                            = 2                           # The exponent used in the norm.
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementW1pError
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementalVariableValue]
    elementid                    = (required)                  # The ID of the element where we monitor
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = ElementalVariableValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The variable to be monitored
  [../]

  [./EmptyPostprocessor]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = EmptyPostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./ExecutionerAttributeReporter]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = ExecutionerAttributeReporter
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./FunctionSideIntegral]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = 1                           # This postprocessor will return the integral of this function over the ...
                                                               # boundary
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = FunctionSideIntegral
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NodalExtremeValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalExtremeValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value_type                   = max                         # Type of extreme value to return. 'max' returns the maximum value. 'min' ...
                                                               # returns the minimum value.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalL2Error]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalL2Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalL2Norm]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalL2Norm
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalMaxValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalMaxValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalProxyMaxValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalProxyMaxValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalSum]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalSum
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalVariableValue]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    nodeid                       = (required)                  # The ID of the node where we monitor
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    scale_factor                 = 1                           # A scale factor to be applied to the variable
    type                         = NodalVariableValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The variable to be monitored
  [../]

  [./NumDOFs]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumDOFs
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumElems]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumElems
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumLinearIterations]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumLinearIterations
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumNodes]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumNodes
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumNonlinearIterations]
    accumulate_over_step         = 0                           # When set to true, accumulates to count the total over all Picard iterations ...
                                                               # for each step
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumNonlinearIterations
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumPicardIterations]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumPicardIterations
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumResidualEvaluations]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumResidualEvaluations
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumVars]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    system                       = nonlinear                   # The system for which you want to print the number of variables.
    type                         = NumVars
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./PerformanceData]
    column                       = (required)                  # The column you want the value of.
    event                        = (required)                  # The name of the event.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = PerformanceData
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./PlotFunction]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # Name of the function to plot (i.e. sample)
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    point                        =                             # A point in space to be given to the function
    scale_factor                 = 1                           # A scale factor to be applied to the function
    type                         = PlotFunction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./PointValue]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    point                        = (required)                  # The physical point where the solution will be evaluated.
    type                         = PointValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on.
  [../]

  [./Receiver]
    default                      =                             # The default value
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    initialize_old               = 1                           # Initialize the old postprocessor value with the default value
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = Receiver
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./Residual]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = Residual
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./RunTime]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    time_type                    = (required)                  # Whether to output the total elapsed or just the active time
    type                         = RunTime
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./ScalarL2Error]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = ScalarL2Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the scalar variable
  [../]

  [./ScalarVariable]
    component                    = 0                           # Component to output for this variable
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = ScalarVariable
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # Name of the variable
  [../]

  [./SideAverageValue]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = SideAverageValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SideFluxAverage]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diffusivity                  = (required)                  # The name of the diffusivity material property that will be used in the ...
                                                               # flux computation.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = SideFluxAverage
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SideFluxIntegral]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diffusivity                  = (required)                  # The name of the diffusivity material property that will be used in the ...
                                                               # flux computation.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = SideFluxIntegral
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SideIntegralVariablePostprocessor]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = SideIntegralVariablePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./TimePostprocessor]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    fractional_scale             = 1e+06                       # The value that the fractional portion is scaled
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    time_part                    =                             # Limits the output to the portion of time to report (interger or fractional), ...
                                                               # leaving this empty reports the complete time.
    type                         = TimePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./TimestepSize]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = TimestepSize
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./TotalVariableValue]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = TotalVariableValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        =                             # The name of the postprocessor
  [../]

  [./VolumePostprocessor]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = VolumePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]
[]

[Preconditioning]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
    line_search                  = default                     # Specifies the line search type (Note: none = basic)
    petsc_options                =                             # Singleton PETSc options
    petsc_options_iname          =                             # Names of PETSc name/value pairs
    petsc_options_value          =                             # Values of PETSc name/value pairs (must correspond with "petsc_options_iname"
    solve_type                   =                             # PJFNK: Preconditioned Jacobian-Free Newton Krylov JFNK: Jacobian-Free ...
                                                               # Newton Krylov NEWTON: Full Newton Solve FD: Use finite differences to ...
                                                               # compute Jacobian LINEAR: Solving a linear problem
  [../]

  [./FDP]
    full                         = 0                           # Set to true if you want the full set of couplings.  Simply for convenience ...
                                                               # so you don't have to set every off_diag_row and off_diag_column combination.
    implicit_geometric_coupling  = 0                           # Set to true if you want to add entries into the matrix for degrees of ...
                                                               # freedom that might be coupled by inspection of the geometric search objects.
    off_diag_column              =                             # The off diagonal column you want to add into the matrix, it will be associated ...
                                                               # with an off diagonal row from the same position in off_diag_row.
    off_diag_row                 =                             # The off diagonal row you want to add into the matrix, it will be associated ...
                                                               # with an off diagonal column from the same position in off_diag_colum.
    pc_side                      = right                       # Preconditioning side
    type                         = FDP
  [../]

  [./PBP]
    off_diag_column              =                             # The off diagonal column you want to add into the matrix, it will be associated ...
                                                               # with an off diagonal row from the same position in off_diag_row.
    off_diag_row                 =                             # The off diagonal row you want to add into the matrix, it will be associated ...
                                                               # with an off diagonal column from the same position in off_diag_colum.
    pc_side                      = right                       # Preconditioning side
    preconditioner               = (required)                  # TODO: docstring
    solve_order                  = (required)                  # The order the block rows will be solved in.  Put the name of variables ...
                                                               # here to stand for solving that variable's block row.  A variable may ...
                                                               # appear more than once (to create cylces if you like).
    type                         = PBP
  [../]

  [./SBP]
    full                         = 0                           # Set to true if you want the full set of couplings.  Simply for convenience ...
                                                               # so you don't have to set every off_diag_row and off_diag_column combination.
    off_diag_column              =                             # The off diagonal column you want to add into the matrix, it will be associated ...
                                                               # with an off diagonal row from the same position in off_diag_row.
    off_diag_row                 =                             # The off diagonal row you want to add into the matrix, it will be associated ...
                                                               # with an off diagonal column from the same position in off_diag_colum.
    pc_side                      = right                       # Preconditioning side
    type                         = SBP
  [../]

  [./SMP]
    full                         = 0                           # Set to true if you want the full set of couplings.  Simply for convenience ...
                                                               # so you don't have to set every off_diag_row and off_diag_column combination.
    off_diag_column              =                             # The off diagonal column you want to add into the matrix, it will be associated ...
                                                               # with an off diagonal row from the same position in off_diag_row.
    off_diag_row                 =                             # The off diagonal row you want to add into the matrix, it will be associated ...
                                                               # with an off diagonal column from the same position in off_diag_colum.
    pc_side                      = right                       # Preconditioning side
    type                         = SMP
  [../]
[]

[Problem]
  active                         = __all__                     # If specified only the blocks named will be visited and made active
  block                          =                             # Block IDs for the coordinate systems
  coord_type                     = XYZ                         # Type of the coordinate system per block param
  fe_cache                       = 0                           # Whether or not to turn on the finite element shape function caching system. ...
                                                               # This can increase speed with an associated memory cost.
  kernel_coverage_check          = 1                           # Set to false to disable kernel->subdomain kernel coverage check
  name                           = 'MOOSE Problem'             # The name the problem
  rz_coord_axis                  = Y                           # The rotation axis (X | Y) for axisymetric coordinates
  type                           = FEProblem                   # A string representing the Moose Object that will be built by this Action
  use_legacy_uo_aux_computation  =                             # Set to true to have MOOSE recompute *all* AuxKernel types every time ...
                                                               # *any* UserObject type is executed. ... This behavior is non-intuitive ...
                                                               # and will be removed late fall 2014, The default is controlled through ...
                                                               # MooseApp
  use_legacy_uo_initialization   =                             # Set to true to have MOOSE compute all UserObjects and Postprocessors ...
                                                               # during the initial setup phase of the problem recompute *all* AuxKernel ...
                                                               # types every time *any* UserObject type is executed. ... This behavior ...
                                                               # is non-intuitive and will be removed late fall 2014, The default is controlled ...
                                                               # through MooseApp
  library_path                   =                             # Path to search for dynamic libraries (please avoid committing absolute ...
                                                               # paths in addition to MOOSE_LIBRARY_PATH)
  object_names                   =                             # The names of the objects to register (Default: register all).
  register_objects_from          =                             # The names of other applications from which objects will be registered ...
                                                               # from (dynamic registration).

  [./<type>]

    [./FEProblem]
      dimNearNullSpace           = 0                           # The dimension of the near nullspace
      dimNullSpace               = 0                           # The dimension of the nullspace
      error_on_jacobian_nonzero_reallocation = 0                           # This causes PETSc to error if it had to reallocate memory in the Jacobian ...
                                                               # matrix due to not having enough nonzeros
      solve                      = 1                           # Whether or not to actually solve the Nonlinear system.  This is handy ...
                                                               # in the case that all you want to do is execute AuxKernels, Transfers, ...
                                                               # etc. without actually solving anything
      type                       = FEProblem
      use_nonlinear              = 1                           # Determines whether to use a Nonlinear vs a Eigenvalue system (Automatically ...
                                                               # determined based on executioner)
    [../]
  [../]
[]

[ScalarKernels]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./NodalEqualValueConstraint]
    nodes                        = (required)                  # Node ids
    type                         = NodalEqualValueConstraint
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    var                          = (required)                  # Variable(s) to put the constraint on
    variable                     = (required)                  # The name of the variable that this kernel operates on
  [../]

  [./ODETimeDerivative]
    type                         = ODETimeDerivative
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this kernel operates on
  [../]

  [./ParsedODEKernel]
    args                         =                             # additional coupled variables
    constant_expressions         =                             # Vector of values for the constants in constant_names (can be an FParser ...
                                                               # expression)
    constant_names               =                             # Vector of constants used in the parsed function (use this for kB etc.)
    disable_fpoptimizer          = 0                           # Disable the function parser algebraic optimizer
    enable_jit                   = 1                           # enable just-in-time compilation of function expressions for faster evaluation
    fail_on_evalerror            = 0                           # Fail fatally if a function evaluation returns an error code (otherwise ...
                                                               # just pass on NaN)
    function                     = (required)                  # function expression
    type                         = ParsedODEKernel
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this kernel operates on
  [../]
[]

[Splits]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
    type                         = Split                       # Classname of the split object
  [../]

  [./ContactSplit]
    blocks                       =                             # Mesh blocks Split operates on (omitting this implies "all blocks"
    contact_displaced            =                             # List of indicators whether displaced mesh is used to define included ...
                                                               # contact
    contact_master               =                             # Master surface list for included contacts
    contact_slave                =                             # Slave surface list for included contacts
    petsc_options                =                             # PETSc flags for the FieldSplit solver
    petsc_options_iname          =                             # PETSc option names for the FieldSplit solver
    petsc_options_value          =                             # PETSc option values for the FieldSplit solver
    schur_ainv                   = diag                        # Type of approximation to inv(A) used when forming S = D - C inv(A) B
    schur_pre                    = S                           # Type of Schur complement preconditioner matrix
    schur_type                   = full                        # Type of Schur complement
    sides                        =                             # Sidesets Split operates on (omitting this implies "no sidesets"
    splitting                    =                             # The names of the splits (subsystems) in the decomposition of this split
    splitting_type               = additive                    # Split decomposition type
    type                         = ContactSplit
    uncontact_displaced          =                             # List of indicators whether displaced mesh is used to define excluded ...
                                                               # contact
    uncontact_master             =                             # Master surface list for excluded contacts
    uncontact_slave              =                             # Slave surface list for excluded contacts
    unsides                      =                             # Sidesets Split excludes (omitting this implies "do not exclude any sidesets"
    vars                         =                             # Variables Split operates on (omitting this implies "all variables"
  [../]

  [./Split]
    blocks                       =                             # Mesh blocks Split operates on (omitting this implies "all blocks"
    petsc_options                =                             # PETSc flags for the FieldSplit solver
    petsc_options_iname          =                             # PETSc option names for the FieldSplit solver
    petsc_options_value          =                             # PETSc option values for the FieldSplit solver
    schur_ainv                   = diag                        # Type of approximation to inv(A) used when forming S = D - C inv(A) B
    schur_pre                    = S                           # Type of Schur complement preconditioner matrix
    schur_type                   = full                        # Type of Schur complement
    sides                        =                             # Sidesets Split operates on (omitting this implies "no sidesets"
    splitting                    =                             # The names of the splits (subsystems) in the decomposition of this split
    splitting_type               = additive                    # Split decomposition type
    type                         = Split
    unsides                      =                             # Sidesets Split excludes (omitting this implies "do not exclude any sidesets"
    vars                         =                             # Variables Split operates on (omitting this implies "all variables"
  [../]
[]

[Transfers]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./MultiAppCopyTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    multi_app                    = (required)                  # The name of the MultiApp to use.
    source_variable              = (required)                  # The variable to transfer from.
    type                         = MultiAppCopyTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The auxiliary variable to store the transferred values in.
  [../]

  [./MultiAppInterpolationTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    displaced_source_mesh        = 0                           # Whether or not to use the displaced mesh for the source mesh.
    displaced_target_mesh        = 0                           # Whether or not to use the displaced mesh for the target mesh.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    interp_type                  = inverse_distance            # The algorithm to use for interpolation.
    multi_app                    = (required)                  # The name of the MultiApp to use.
    num_points                   = 3                           # The number of nearest points to use for interpolation.
    power                        = 2                           # The polynomial power to use for calculation of the decay in the interpolation.
    radius                       = -1                          # Radius to use for radial_basis interpolation.  If negative then the radius ...
                                                               # is taken as the max distance between points.
    source_variable              = (required)                  # The variable to transfer from.
    type                         = MultiAppInterpolationTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The auxiliary variable to store the transferred values in.
  [../]

  [./MultiAppMeshFunctionTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    displaced_source_mesh        = 0                           # Whether or not to use the displaced mesh for the source mesh.
    displaced_target_mesh        = 0                           # Whether or not to use the displaced mesh for the target mesh.
    error_on_miss                = 0                           # Whether or not to error in the case that a target point is not found ...
                                                               # in the source domain.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    multi_app                    = (required)                  # The name of the MultiApp to use.
    source_variable              = (required)                  # The variable to transfer from.
    type                         = MultiAppMeshFunctionTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The auxiliary variable to store the transferred values in.
  [../]

  [./MultiAppNearestNodeTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    displaced_source_mesh        = 0                           # Whether or not to use the displaced mesh for the source mesh.
    displaced_target_mesh        = 0                           # Whether or not to use the displaced mesh for the target mesh.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    fixed_meshes                 = 0                           # Set to true when the meshes are not changing (ie, no movement or adaptivity). ...
                                                               # This will cache nearest node neighbors to greatly speed up the transfer.
    multi_app                    = (required)                  # The name of the MultiApp to use.
    source_boundary              =                             # The boundary we are transferring from (if not specified, whole domain ...
                                                               # is used).
    source_variable              = (required)                  # The variable to transfer from.
    type                         = MultiAppNearestNodeTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The auxiliary variable to store the transferred values in.
  [../]

  [./MultiAppPostprocessorInterpolationTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    interp_type                  = inverse_distance            # The algorithm to use for interpolation.
    multi_app                    = (required)                  # The name of the MultiApp to use.
    num_points                   = 3                           # The number of nearest points to use for interpolation.
    postprocessor                = (required)                  # The Postprocessor to interpolate.
    power                        = 2                           # The polynomial power to use for calculation of the decay in the interpolation.
    radius                       = -1                          # Radius to use for radial_basis interpolation.  If negative then the radius ...
                                                               # is taken as the max distance between points.
    type                         = MultiAppPostprocessorInterpolationTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The auxiliary variable to store the transferred values in.
  [../]

  [./MultiAppPostprocessorToAuxScalarTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    from_postprocessor           = (required)                  # The name of the Postprocessor in the Master to transfer the value from.
    multi_app                    = (required)                  # The name of the MultiApp to use.
    to_aux_scalar                = (required)                  # The name of the scalar Aux variable in the MultiApp to transfer the value ...
                                                               # to.
    type                         = MultiAppPostprocessorToAuxScalarTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./MultiAppPostprocessorTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    from_postprocessor           = (required)                  # The name of the Postprocessor in the Master to transfer the value from.
    multi_app                    = (required)                  # The name of the MultiApp to use.
    reduction_type               =                             # The type of reduction to perform to reduce postprocessor values from ...
                                                               # multiple SubApps to a single value
    to_postprocessor             = (required)                  # The name of the Postprocessor in the MultiApp to transfer the value to. ...
                                                               # This should most likely be a Reporter Postprocessor.
    type                         = MultiAppPostprocessorTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./MultiAppProjectionTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    family                       = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
    multi_app                    = (required)                  # The name of the MultiApp to use.
    order                        = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
    proj_type                    = l2                          # The type of the projection.
    source_variable              = (required)                  # The variable to transfer from.
    type                         = MultiAppProjectionTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The auxiliary variable to store the transferred values in.
  [../]

  [./MultiAppUserObjectTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    displaced_target_mesh        = 0                           # Whether or not to use the displaced mesh for the target mesh.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    multi_app                    = (required)                  # The name of the MultiApp to use.
    type                         = MultiAppUserObjectTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    user_object                  = (required)                  # The UserObject you want to transfer values from.  Note: This might be ...
                                                               # a UserObject from your MultiApp's input file!
    variable                     = (required)                  # The auxiliary variable to store the transferred values in.
  [../]

  [./MultiAppVariableValueSamplePostprocessorTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    multi_app                    = (required)                  # The name of the MultiApp to use.
    postprocessor                = (required)                  # The name of the postprocessor in the MultiApp to transfer the value to. ...
                                                               # This should most likely be a Reporter Postprocessor.
    source_variable              = (required)                  # The variable to transfer from.
    type                         = MultiAppVariableValueSamplePostprocessorTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./MultiAppVariableValueSampleTransfer]
    direction                    = (required)                  # Whether this Transfer will be 'to' or 'from' a MultiApp.
    execute_on                   = SAME_AS_MULTIAPP            # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    multi_app                    = (required)                  # The name of the MultiApp to use.
    source_variable              = (required)                  # The variable to transfer from.
    type                         = MultiAppVariableValueSampleTransfer
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The auxiliary variable to store the transferred values in.
  [../]
[]

[UserObjects]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./AreaPostprocessor]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = AreaPostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./AverageElementSize]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = AverageElementSize
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./AverageNodalVariableValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = AverageNodalVariableValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./BlockAverageValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    built_by_action              = add_user_object
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = BlockAverageValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./DifferencePostprocessor]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = DifferencePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value1                       = (required)                  # First value
    value2                       = (required)                  # Second value
  [../]

  [./ElementAverageTimeDerivative]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementAverageTimeDerivative
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementAverageValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementAverageValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementExtremeValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementExtremeValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value_type                   = max                         # Type of extreme value to return. 'max' returns the maximum value. 'min' ...
                                                               # returns the minimum value.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./ElementH1Error]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    p                            = 2                           # The exponent used in the norm.
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementH1Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementH1SemiError]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementH1SemiError
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementIntegralMaterialProperty]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    mat_prop                     = (required)                  # The name of the material property
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementIntegralMaterialProperty
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./ElementIntegralVariablePostprocessor]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementIntegralVariablePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementIntegralVariableUserObject]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementIntegralVariableUserObject
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementL2Error]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementL2Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementL2Norm]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementL2Norm
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementVectorL2Error]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function_x                   = (required)                  # The analytic solution to compare against
    function_y                   = 0                           # The analytic solution to compare against
    function_z                   = 0                           # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementVectorL2Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    var_x                        = (required)                  # The FE solution in x direction
    var_y                        = 0                           # The FE solution in y direction
    var_z                        = 0                           # The FE solution in z direction
  [../]

  [./ElementW1pError]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    p                            = 2                           # The exponent used in the norm.
    seed                         = 0                           # The seed for the master random number generator
    type                         = ElementW1pError
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./ElementalVariableValue]
    elementid                    = (required)                  # The ID of the element where we monitor
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = ElementalVariableValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The variable to be monitored
  [../]

  [./EmptyPostprocessor]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = EmptyPostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./ExecutionerAttributeReporter]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = ExecutionerAttributeReporter
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./FunctionSideIntegral]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = 1                           # This postprocessor will return the integral of this function over the ...
                                                               # boundary
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = FunctionSideIntegral
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./LayeredAverage]
    average_radius               = 1                           # When using 'average' sampling this is how the number of values both above ...
                                                               # and below the layer that will be averaged.
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    bounds                       =                             # The 'bounding' positions of the layers i.e.: '0, 1.2, 3.7, 4.2' will ...
                                                               # mean 3 layers between those positions.
    direction                    = (required)                  # The direction of the layers.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    num_layers                   =                             # The number of layers.
    sample_type                  = direct                      # How to sample the layers.  'direct' means get the value of the layer ...
                                                               # the point falls in directly (or average if that layer has no value). ...
                                                               # 'interpolate' does a linear interpolation between the two closest layers. ...
                                                               # 'average' averages the two closest layers.
    seed                         = 0                           # The seed for the master random number generator
    type                         = LayeredAverage
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./LayeredIntegral]
    average_radius               = 1                           # When using 'average' sampling this is how the number of values both above ...
                                                               # and below the layer that will be averaged.
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    bounds                       =                             # The 'bounding' positions of the layers i.e.: '0, 1.2, 3.7, 4.2' will ...
                                                               # mean 3 layers between those positions.
    direction                    = (required)                  # The direction of the layers.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    num_layers                   =                             # The number of layers.
    sample_type                  = direct                      # How to sample the layers.  'direct' means get the value of the layer ...
                                                               # the point falls in directly (or average if that layer has no value). ...
                                                               # 'interpolate' does a linear interpolation between the two closest layers. ...
                                                               # 'average' averages the two closest layers.
    seed                         = 0                           # The seed for the master random number generator
    type                         = LayeredIntegral
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./LayeredSideAverage]
    average_radius               = 1                           # When using 'average' sampling this is how the number of values both above ...
                                                               # and below the layer that will be averaged.
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    bounds                       =                             # The 'bounding' positions of the layers i.e.: '0, 1.2, 3.7, 4.2' will ...
                                                               # mean 3 layers between those positions.
    direction                    = (required)                  # The direction of the layers.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    num_layers                   =                             # The number of layers.
    sample_type                  = direct                      # How to sample the layers.  'direct' means get the value of the layer ...
                                                               # the point falls in directly (or average if that layer has no value). ...
                                                               # 'interpolate' does a linear interpolation between the two closest layers. ...
                                                               # 'average' averages the two closest layers.
    type                         = LayeredSideAverage
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./LayeredSideFluxAverage]
    average_radius               = 1                           # When using 'average' sampling this is how the number of values both above ...
                                                               # and below the layer that will be averaged.
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    bounds                       =                             # The 'bounding' positions of the layers i.e.: '0, 1.2, 3.7, 4.2' will ...
                                                               # mean 3 layers between those positions.
    diffusivity                  = (required)                  # The name of the diffusivity material property that will be used in the ...
                                                               # flux computation.
    direction                    = (required)                  # The direction of the layers.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    num_layers                   =                             # The number of layers.
    sample_type                  = direct                      # How to sample the layers.  'direct' means get the value of the layer ...
                                                               # the point falls in directly (or average if that layer has no value). ...
                                                               # 'interpolate' does a linear interpolation between the two closest layers. ...
                                                               # 'average' averages the two closest layers.
    type                         = LayeredSideFluxAverage
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./LayeredSideIntegral]
    average_radius               = 1                           # When using 'average' sampling this is how the number of values both above ...
                                                               # and below the layer that will be averaged.
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    bounds                       =                             # The 'bounding' positions of the layers i.e.: '0, 1.2, 3.7, 4.2' will ...
                                                               # mean 3 layers between those positions.
    direction                    = (required)                  # The direction of the layers.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    num_layers                   =                             # The number of layers.
    sample_type                  = direct                      # How to sample the layers.  'direct' means get the value of the layer ...
                                                               # the point falls in directly (or average if that layer has no value). ...
                                                               # 'interpolate' does a linear interpolation between the two closest layers. ...
                                                               # 'average' averages the two closest layers.
    type                         = LayeredSideIntegral
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./NearestPointLayeredAverage]
    average_radius               = 1                           # When using 'average' sampling this is how the number of values both above ...
                                                               # and below the layer that will be averaged.
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    bounds                       =                             # The 'bounding' positions of the layers i.e.: '0, 1.2, 3.7, 4.2' will ...
                                                               # mean 3 layers between those positions.
    direction                    = (required)                  # The direction of the layers.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    num_layers                   =                             # The number of layers.
    points                       = (required)                  # Layered averages will be computed in space closest to these points.
    sample_type                  = direct                      # How to sample the layers.  'direct' means get the value of the layer ...
                                                               # the point falls in directly (or average if that layer has no value). ...
                                                               # 'interpolate' does a linear interpolation between the two closest layers. ...
                                                               # 'average' averages the two closest layers.
    seed                         = 0                           # The seed for the master random number generator
    type                         = NearestPointLayeredAverage
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this object operates on
  [../]

  [./NodalExtremeValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalExtremeValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value_type                   = max                         # Type of extreme value to return. 'max' returns the maximum value. 'min' ...
                                                               # returns the minimum value.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalL2Error]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalL2Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalL2Norm]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalL2Norm
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalMaxValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalMaxValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalNormalsCorner]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    corner_boundary              = (required)                  # Node set ID which contains the nodes that are in 'corners'.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    type                         = NodalNormalsCorner
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NodalNormalsEvaluator]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalNormalsEvaluator
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NodalNormalsPreprocessor]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    corner_boundary              =                             # Node set ID which contains the nodes that are in 'corners'.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalNormalsPreprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NodalProxyMaxValue]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalProxyMaxValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalSum]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = NodalSum
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on
  [../]

  [./NodalVariableValue]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    nodeid                       = (required)                  # The ID of the node where we monitor
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    scale_factor                 = 1                           # A scale factor to be applied to the variable
    type                         = NodalVariableValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The variable to be monitored
  [../]

  [./NumDOFs]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumDOFs
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumElems]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumElems
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumLinearIterations]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumLinearIterations
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumNodes]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumNodes
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumNonlinearIterations]
    accumulate_over_step         = 0                           # When set to true, accumulates to count the total over all Picard iterations ...
                                                               # for each step
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumNonlinearIterations
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumPicardIterations]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumPicardIterations
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumResidualEvaluations]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = NumResidualEvaluations
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./NumVars]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    system                       = nonlinear                   # The system for which you want to print the number of variables.
    type                         = NumVars
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./PerformanceData]
    column                       = (required)                  # The column you want the value of.
    event                        = (required)                  # The name of the event.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = PerformanceData
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./PlotFunction]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # Name of the function to plot (i.e. sample)
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    point                        =                             # A point in space to be given to the function
    scale_factor                 = 1                           # A scale factor to be applied to the function
    type                         = PlotFunction
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./PointValue]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    point                        = (required)                  # The physical point where the solution will be evaluated.
    type                         = PointValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this postprocessor operates on.
  [../]

  [./Receiver]
    default                      =                             # The default value
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    initialize_old               = 1                           # Initialize the old postprocessor value with the default value
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = Receiver
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./Residual]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = Residual
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./RunTime]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    time_type                    = (required)                  # Whether to output the total elapsed or just the active time
    type                         = RunTime
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./ScalarL2Error]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    function                     = (required)                  # The analytic solution to compare against
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = ScalarL2Error
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the scalar variable
  [../]

  [./ScalarVariable]
    component                    = 0                           # Component to output for this variable
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = ScalarVariable
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # Name of the variable
  [../]

  [./SideAverageValue]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = SideAverageValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SideFluxAverage]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diffusivity                  = (required)                  # The name of the diffusivity material property that will be used in the ...
                                                               # flux computation.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = SideFluxAverage
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SideFluxIntegral]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    diffusivity                  = (required)                  # The name of the diffusivity material property that will be used in the ...
                                                               # flux computation.
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = SideFluxIntegral
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SideIntegralVariablePostprocessor]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = SideIntegralVariablePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The name of the variable that this boundary condition applies to
  [../]

  [./SolutionUserObject]
    coord_factor                 =                             # This name has been deprecated.
    coord_scale                  =                             # This name has been deprecated.
    es                           = '<not supplied>'            # The name of the file holding the equation system info in xda format (xda ...
                                                               # only).
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    mesh                         = (required)                  # The name of the mesh file (must be xda or exodusII file).
    rotation0_angle              = 0                           # Anticlockwise rotation angle (in degrees) to use for rotation about rotation0_vector.
    rotation0_vector             = '(x,y,z)=(       0,        0,        1)'# Vector about which to rotate points of the simulation.
    rotation1_angle              = 0                           # Anticlockwise rotation angle (in degrees) to use for rotation about rotation1_vector.
    rotation1_vector             = '(x,y,z)=(       0,        0,        1)'# Vector about which to rotate points of the simulation.
    scale                        = '1 1 1'                     # Scale factor for points in the simulation
    scale_multiplier             = '1 1 1'                     # Scale multiplying factor for points in the simulation
    system                       = nl0                         # The name of the system to pull values out of (xda only).
    system_variables             =                             # The name of the nodal and elemental variables from the file you want ...
                                                               # to use for values
    timestep                     = -1                          # Index of the single timestep used (exodusII only).  If not supplied, ...
                                                               # time interpolation will occur.
    transformation_order         = 'SCALE TRANSLATION'         # The order to perform the operations in.  Define R0 to be the rotation ...
                                                               # matrix encoded by rotation0_vector and rotation0_angle.  Similarly for ...
                                                               # R1.  Denote the scale by s, the scale_multiplier by m, and the translation ...
                                                               # by t.  Then, given a point x in the simulation, if transformation_order ...
                                                               # = 'rotation0 scale_multiplier translation scale rotation1' then form ...
                                                               # p = R1*(R0*x*m - t)/s.  Then the values provided by the SolutionUserObject ...
                                                               # at point x in the simulation are the variable values at point p in the ...
                                                               # mesh.
    translation                  = '0 0 0'                     # Translation factors for x,y,z coordinates of the simulation
    type                         = SolutionUserObject
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./Terminator]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    expression                   = (required)                  # FParser expression to process Postprocessor values into a boolean value. ...
                                                               # Termination of the simulation occurs when this returns true.
    type                         = Terminator
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./TimePostprocessor]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    fractional_scale             = 1e+06                       # The value that the fractional portion is scaled
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    time_part                    =                             # Limits the output to the portion of time to report (interger or fractional), ...
                                                               # leaving this empty reports the complete time.
    type                         = TimePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./TimestepSize]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = TimestepSize
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./TotalVariableValue]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    type                         = TotalVariableValue
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        =                             # The name of the postprocessor
  [../]

  [./VolumePostprocessor]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    seed                         = 0                           # The seed for the master random number generator
    type                         = VolumePostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]
[]

[Variables]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
    block                        =                             # The block id where this variable lives
    eigen                        = 0                           # True to make this variable an eigen variable
    family                       = LAGRANGE                    # Specifies the family of FE shape functions to use for this variable
    initial_condition            = 0                           # Specifies the initial condition for this variable
    order                        = FIRST                       # Specifies the order of the FE shape function to use for this variable ...
                                                               # (additional orders not listed are allowed)
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # variables(s) associated with this object
    scaling                      = 1                           # Specifies a scaling factor to apply to this variable
    initial_from_file_timestep   = 2                           # Gives the timestep for which to read a solution from a file for a given ...
                                                               # variable
    initial_from_file_var        =                             # Gives the name of a variable for which to read an initial condition from ...
                                                               # a mesh file

    [./InitialCondition]
      active                     = __all__                     # If specified only the blocks named will be visited and made active

      [./<type>]

        [./BoundingBoxIC]
          block                  =                             # The list of block ids (SubdomainID) that this object will be applied
          boundary               =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
          inside                 = 0                           # The value of the variable inside the box
          outside                = 0                           # The value of the variable outside the box
          type                   = BoundingBoxIC
          variable               = (required)                  # The variable this initial condition is supposed to provide values for.
          x1                     = (required)                  # The x coordinate of the lower left-hand corner of the box
          x2                     = (required)                  # The x coordinate of the upper right-hand corner of the box
          y1                     = (required)                  # The y coordinate of the lower left-hand corner of the box
          y2                     = (required)                  # The y coordinate of the upper right-hand corner of the box
          z1                     = 0                           # The z coordinate of the lower left-hand corner of the box
          z2                     = 0                           # The z coordinate of the upper right-hand corner of the box
        [../]

        [./ConstantIC]
          block                  =                             # The list of block ids (SubdomainID) that this object will be applied
          boundary               =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
          type                   = ConstantIC
          value                  = (required)                  # The value to be set in IC
          variable               = (required)                  # The variable this initial condition is supposed to provide values for.
        [../]

        [./FunctionIC]
          block                  =                             # The list of block ids (SubdomainID) that this object will be applied
          boundary               =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
          function               = (required)                  # The initial condition function.
          type                   = FunctionIC
          variable               = (required)                  # The variable this initial condition is supposed to provide values for.
        [../]

        [./RandomIC]
          block                  =                             # The list of block ids (SubdomainID) that this object will be applied
          boundary               =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
          max                    = 1                           # Upper bound of the randomly generated values
          min                    = 0                           # Lower bound of the randomly generated values
          seed                   = 0                           # Seed value for the random number generator
          type                   = RandomIC
          variable               = (required)                  # The variable this initial condition is supposed to provide values for.
        [../]

        [./ScalarComponentIC]
          type                   = ScalarComponentIC
          values                 = (required)                  # Initial values to initialize the scalar variable.
          variable               =                             # The variable this initial condition is supposed to provide values for.
        [../]

        [./ScalarConstantIC]
          type                   = ScalarConstantIC
          value                  = 0
          variable               =                             # The variable this initial condition is supposed to provide values for.
        [../]
      [../]
    [../]
  [../]
[]

[VectorPostprocessors]

  [./*]
    active                       = __all__                     # If specified only the blocks named will be visited and made active
  [../]

  [./ConstantVectorPostprocessor]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    type                         = ConstantVectorPostprocessor
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    value                        = (required)                  # The vector value this object will have.
  [../]

  [./ElementsAlongLine]
    end                          = (required)                  # The end of the line
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    start                        = (required)                  # The beginning of the line
    type                         = ElementsAlongLine
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./LeastSquaresFit]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    num_samples                  =                             # The number of samples to be output
    order                        = (required)                  # The order of the polynomial fit
    output                       = Coefficients                # The quantity to output.  Options are: Coefficients Samples
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    sample_x_max                 =                             # The maximum x value of the of samples to be output
    sample_x_min                 =                             # The minimum x value of the of samples to be output
    type                         = LeastSquaresFit
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    vectorpostprocessor          = (required)                  # The vectorpostprocessor on whose values we perform a least squares fit
    x_name                       = (required)                  # The name of the independent variable
    y_name                       = (required)                  # The name of the dependent variable
  [../]

  [./LineMaterialRealSampler]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    end                          = (required)                  # The end of the line
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    property                     = (required)                  # Name of the material property to be output along a line
    sort_by                      = (required)                  # What to sort the samples by
    start                        = (required)                  # The beginning of the line
    type                         = LineMaterialRealSampler
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]

  [./LineValueSampler]
    end_point                    = (required)                  # The ending of the line
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    num_points                   = (required)                  # The number of points to sample along the line
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    sort_by                      = (required)                  # What to sort the samples by
    start_point                  = (required)                  # The beginning of the line
    type                         = LineValueSampler
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The names of the variables that this VectorPostprocessor operates on
  [../]

  [./NodalValueSampler]
    block                        =                             # The list of block ids (SubdomainID) that this object will be applied
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    seed                         = 0                           # The seed for the master random number generator
    sort_by                      = (required)                  # What to sort the samples by
    type                         = NodalValueSampler
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The names of the variables that this VectorPostprocessor operates on
  [../]

  [./PointValueSampler]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    points                       = (required)                  # The points where you want to evaluate the variables
    sort_by                      = (required)                  # What to sort the samples by
    type                         = PointValueSampler
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The names of the variables that this VectorPostprocessor operates on
  [../]

  [./SideValueSampler]
    boundary                     =                             # The list of boundary IDs from the mesh where this boundary condition ...
                                                               # applies
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    sort_by                      = (required)                  # What to sort the samples by
    type                         = SideValueSampler
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
    variable                     = (required)                  # The names of the variables that this VectorPostprocessor operates on
  [../]

  [./VectorOfPostprocessors]
    execute_on                   = TIMESTEP_END                # Set to (nonlinear|linear|timestep_end|timestep_begin|custom) to execute ...
                                                               # only at that moment
    outputs                      =                             # Vector of output names were you would like to restrict the output of ...
                                                               # this VectorPostprocessor (empty outputs to all)
    postprocessors               = (required)                  # The postprocessors whose values are to be reported
    type                         = VectorOfPostprocessors
    use_displaced_mesh           = 0                           # Whether or not this object should use the displaced mesh for computation. ...
                                                               # Note that in the case this is true but no displacements are provided ...
                                                               # in the Mesh block the undisplaced mesh will still be used.
  [../]
[]
